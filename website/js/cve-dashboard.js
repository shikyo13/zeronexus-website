/**
 * CVE Dashboard JavaScript
 * Interactive features for the CVE Vulnerability Dashboard
 */

document.addEventListener('DOMContentLoaded', function() {
  console.log('CVE Dashboard JavaScript loaded');
  
  // DOM elements
  const searchInput = document.getElementById('cve-search');
  const searchButton = document.getElementById('search-btn');
  const searchType = document.getElementById('search-type');
  const yearFilter = document.getElementById('year-filter');
  const severityFilter = document.getElementById('severity-filter');
  const sortOrder = document.getElementById('sort-order');
  const cveResults = document.getElementById('cve-results');
  const loadingIndicator = document.getElementById('loading');
  const errorMessage = document.getElementById('error-message');
  const sourceFilters = document.getElementById('source-filters');
  
  console.log('DOM elements found:', {
    searchInput: !!searchInput,
    yearFilter: !!yearFilter,
    severityFilter: !!severityFilter,
    sortOrder: !!sortOrder,
    sourceFilters: !!sourceFilters
  });

  // Stats elements
  const totalCount = document.getElementById('total-count');
  const criticalCount = document.getElementById('critical-count');
  const highCount = document.getElementById('high-count');
  const mediumCount = document.getElementById('medium-count');

  // Modal elements
  const cveDetailModal = document.getElementById('cve-detail-modal');
  const cveDetailTitle = document.getElementById('cve-detail-title');
  const cveDetailContent = document.getElementById('cve-detail-content');
  const cveExternalLink = document.getElementById('cve-external-link');

  // Modals initialization
  const detailModal = new bootstrap.Modal(cveDetailModal);

  // Global variables
  let currentCVEs = [];

  /**
   * Gets current filter state from DOM elements (single source of truth)
   */
  function getCurrentFilters() {
    const filters = {
      searchTerm: searchInput.value.trim(),
      searchType: searchType.value,
      year: yearFilter.value,
      severity: severityFilter.value,
      sources: getActiveSources(),
      sortOrder: sortOrder.value === 'asc' ? 'date_asc' : 'date_desc'
    };
    console.log('getCurrentFilters() returning:', filters);
    return filters;
  }

  /**
   * Gets currently active sources from checkboxes
   */
  function getActiveSources() {
    if (!sourceFilters) return ['nvd', 'mitre', 'cisa'];
    const checkedBoxes = sourceFilters.querySelectorAll('input[type="checkbox"]:checked');
    const activeSources = Array.from(checkedBoxes).map(cb => cb.getAttribute('data-source'));
    return activeSources.length > 0 ? activeSources : ['nvd', 'mitre', 'cisa'];
  }

  /**
   * Builds API URL with all current filters
   */
  function buildApiUrl(baseEndpoint, filters) {
    let apiUrl = `${baseEndpoint}?_=${Date.now()}`;
    
    Object.entries(filters).forEach(([key, value]) => {
      if (key === 'sources' && Array.isArray(value) && value.length > 0) {
        apiUrl += `&sources=${value.join(',')}`;
      } else if (key === 'sortOrder' && value) {
        apiUrl += `&sort=${value}`;
      } else if (key === 'searchTerm' || key === 'searchType') {
        // Skip these, they're handled by specific search functions
      } else if (value && value !== '') {
        apiUrl += `&${key}=${encodeURIComponent(value)}`;
      }
    });
    
    console.log('Built API URL with filters:', apiUrl, filters);
    return apiUrl;
  }

  /**
   * Refreshes results with all current filters applied
   */
  function refreshWithCurrentFilters() {
    console.log('refreshWithCurrentFilters called');
    const filters = getCurrentFilters();
    console.log('Current filters state:', filters);
    
    if (filters.year) {
      console.log('Fetching by year:', filters.year);
      fetchCVEsByYear(filters.year);
    } else if (filters.searchTerm) {
      console.log('Fetching by search term:', filters.searchTerm, 'type:', filters.searchType);
      if (filters.searchType === 'keyword') {
        searchByKeyword(filters.searchTerm);
      } else if (filters.searchType === 'vendor') {
        searchByVendor(filters.searchTerm);
      } else if (filters.searchType === 'cve-id') {
        searchCVEById(filters.searchTerm);
      }
    } else {
      console.log('Fetching recent CVEs');
      fetchRecentCVEs();
    }
  }
  
  /**
   * Initializes the dashboard
   */
  function initDashboard() {
    // First clear all caches by making a clear cache request
    // Add timestamp to ensure we're clearing the latest version
    const timestamp = Date.now();
    fetch(`/api/cve-combined.php?clearCache=true&_=${timestamp}`)
      .then(response => response.json())
      .then(data => {}) // Cache cleared
      .catch(err => {}); // Failed to clear cache

    // Check for URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const paramYear = urlParams.get('year');
    const paramId = urlParams.get('id');
    const paramKeyword = urlParams.get('keyword');
    const paramVendor = urlParams.get('vendor');
    const paramView = urlParams.get('view');

    // If CVE ID specified in URL, search for it
    if (paramId) {
      searchInput.value = paramId;
      searchType.value = 'cve-id';
      searchCVEById(paramId);
    }
    // If keyword specified in URL, search by keyword
    else if (paramKeyword) {
      searchInput.value = paramKeyword;
      searchType.value = 'keyword';
      searchByKeyword(paramKeyword);
    }
    // If vendor specified in URL, search by vendor
    else if (paramVendor) {
      searchInput.value = paramVendor;
      searchType.value = 'vendor';
      searchByVendor(paramVendor);
    }
    // If year specified in URL, filter by it
    else if (paramYear) {
      yearFilter.value = paramYear;
      fetchCVEsByYear(paramYear);
    }
    // If view=recent, show most recent CVEs (or if no parameters)
    else if (paramView === 'recent' || !paramView) {
      // Reset year filter to show we're not filtering by year
      yearFilter.value = '';
      fetchRecentCVEs();
    }
    
    // Set up event listeners
    setupEventListeners();
  }
  
  /**
   * Sets up all event listeners
   */
  function setupEventListeners() {
    // Search button click
    searchButton.addEventListener('click', function() {
      const searchTerm = searchInput.value.trim();
      if (searchTerm) {
        const type = searchType.value;

        // Get current filter values
        const currentYear = yearFilter.value;

        // Keep all filters - don't reset any filters to allow for combined searching

        // Handle different search types
        switch(type) {
          case 'cve-id':
            // Full or partial CVE ID search
            if (searchTerm.match(/^CVE-\d{4}-\d{4,}$/i)) {
              searchCVEById(searchTerm);
            } else if (searchTerm.match(/^CVE-\d{4}/i)) {
              // Partial CVE ID with year - search for CVEs from that year
              const year = searchTerm.match(/^CVE-(\d{4})/i)[1];
              yearFilter.value = year;
              fetchCVEsByYear(year);
            } else {
              showError('Please enter a valid CVE ID format (e.g., CVE-2023-12345 or CVE-2023)');
            }
            break;

          case 'keyword':
            // Search by keyword, no specific validation needed
            searchByKeyword(searchTerm);
            break;

          case 'vendor':
            // Search by vendor, no specific validation needed
            searchByVendor(searchTerm);
            break;

          default:
            // Unknown search type
            console.error('Unknown search type:', type);
            showError('Please select a valid search type');
        }
      }
    });

    // Set initial placeholder based on selected search type
    const initialType = searchType.value;
    if (initialType === 'cve-id') {
      searchInput.placeholder = 'Search by CVE ID (e.g., CVE-2023-12345)';
    } else if (initialType === 'keyword') {
      searchInput.placeholder = 'Search by keyword (e.g., buffer overflow)';
    } else if (initialType === 'vendor') {
      searchInput.placeholder = 'Search by vendor (e.g., microsoft)';
    }

    // Search input enter key and clear handling
    searchInput.addEventListener('keyup', function(event) {
      // When Enter is pressed, trigger the search
      if (event.key === 'Enter') {
        searchButton.click();
      }

      // If the input is empty, clear the search - check after each keystroke
      if (this.value === '') {
        // Clear the URL parameter for keyword or vendor based on current search type
        const url = new URL(window.location);
        const type = searchType.value;

        if (type === 'keyword') {
          url.searchParams.delete('keyword');
        } else if (type === 'vendor') {
          url.searchParams.delete('vendor');
        } else if (type === 'cve-id') {
          url.searchParams.delete('id');
        }

        // Update URL without reloading the page
        window.history.pushState({}, '', url);

        // Fetch new results based on remaining filters
        refreshWithCurrentFilters();
      }
    });

    // Handle the clear button (x) in search field if browser supports it
    searchInput.addEventListener('search', function() {
      if (this.value === '') {
        // Clear the URL parameter for keyword or vendor based on current search type
        const url = new URL(window.location);
        const type = searchType.value;

        if (type === 'keyword') {
          url.searchParams.delete('keyword');
        } else if (type === 'vendor') {
          url.searchParams.delete('vendor');
        } else if (type === 'cve-id') {
          url.searchParams.delete('id');
        }

        // Update URL without reloading the page
        window.history.pushState({}, '', url);

        // Fetch new results based on remaining filters
        refreshWithCurrentFilters();
      }
    });

    // Update placeholder based on search type
    searchType.addEventListener('change', function() {
      const type = this.value;
      if (type === 'cve-id') {
        searchInput.placeholder = 'Search by CVE ID (e.g., CVE-2023-12345)';
      } else if (type === 'keyword') {
        searchInput.placeholder = 'Search by keyword (e.g., buffer overflow)';
      } else if (type === 'vendor') {
        searchInput.placeholder = 'Search by vendor (e.g., microsoft)';
      }
    });

    // Source filter checkboxes
    if (sourceFilters) {
      const checkboxes = sourceFilters.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          // Update the sources filter
          const checkedBoxes = sourceFilters.querySelectorAll('input[type="checkbox"]:checked');
          const activeSources = Array.from(checkedBoxes).map(cb => cb.getAttribute('data-source'));

          // Ensure at least one source is selected
          if (activeSources.length === 0) {
            this.checked = true;
            return;
          }

          console.log("Sources filter changed to:", activeSources);

          // Add a short delay to prevent multiple rapid requests when checking/unchecking multiple boxes
          setTimeout(function() {
            refreshWithCurrentFilters();
          }, 300);
        });
      });
    }

    // Sort order change
    sortOrder.addEventListener('change', function() {
      // Fetch new data with the sort parameter instead of just re-rendering
      refreshWithCurrentFilters();
    });

    // Year filter change
    yearFilter.addEventListener('change', function() {
      console.log("Year filter changed to:", this.value);
      console.log("Calling refreshWithCurrentFilters from year filter");
      refreshWithCurrentFilters();
    });

    // Severity filter change
    severityFilter.addEventListener('change', function() {
      console.log("Severity filter changed to:", this.value);
      console.log("Calling refreshWithCurrentFilters from severity filter");
      refreshWithCurrentFilters();
    });
    
    console.log('Event listeners attached successfully');
  }

  /**
   * Helper function to refresh the current search with updated filters
   */
  function refreshCurrentSearch() {
    const searchTerm = searchInput.value.trim();
    const type = searchType.value;
    const year = yearFilter.value;

    if (year) {
      // Year is the priority if it's set
      fetchCVEsByYear(year);
    } else if (searchTerm) {
      // Then search term
      if (type === 'keyword') {
        searchByKeyword(searchTerm);
      } else if (type === 'vendor') {
        searchByVendor(searchTerm);
      } else if (type === 'cve-id') {
        searchCVEById(searchTerm);
      }
    } else {
      // No filters, show recent
      fetchRecentCVEs();
    }
  }
  
  /**
   * Searches for a specific CVE by ID
   */
  function searchCVEById(cveId) {
    showLoading();

    // Get all current filters
    const filters = getCurrentFilters();

    // Update URL parameter
    const url = new URL(window.location);
    url.searchParams.set('id', cveId);

    // Clear other search parameters for clarity
    url.searchParams.delete('year');
    url.searchParams.delete('vendor');
    url.searchParams.delete('keyword');
    url.searchParams.delete('view');

    window.history.pushState({}, '', url);

    // Build API URL with all filters using centralized function
    let apiUrl = buildApiUrl('/api/cve-combined.php', filters);
    
    // Add the CVE ID parameter
    apiUrl += `&id=${encodeURIComponent(cveId)}`;

    console.log(`Searching for CVE ${cveId} with filters:`, filters);

    fetch(apiUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        hideLoading();
        
        if (data.error) {
          showError(data.message || 'Error fetching CVE data');
          return;
        }
        
        if (data.vulnerabilities && data.vulnerabilities.length > 0) {
          currentCVEs = data.vulnerabilities;
          renderResults();
          updateStats();
          
          // If only one result, automatically show the detail view
          if (data.vulnerabilities.length === 1) {
            showCVEDetail(data.vulnerabilities[0].cve);
          }
        } else {
          showError(`No data found for ${cveId}`);
          resetStatCounters();
        }
      })
      .catch(error => {
        console.error('Error fetching CVE:', error);
        hideLoading();
        showError('Failed to fetch CVE data. Please try again later.');
        resetStatCounters();
      });
  }
  
  /**
   * Fetches CVEs for a specific year
   */
  function fetchCVEsByYear(year) {
    showLoading();

    // Check if year is in the future
    const currentYear = new Date().getFullYear();
    if (parseInt(year) > currentYear) {
      year = currentYear.toString();
      // Update the year filter in the UI
      yearFilter.value = year;
    }

    // Get all current filters
    const filters = getCurrentFilters();
    filters.year = year; // Override with the specific year

    // Get search parameters
    const searchTerm = filters.searchTerm;
    const searchTypeVal = filters.searchType;

    // Update URL parameter - maintain search parameters
    const url = new URL(window.location);
    url.searchParams.set('year', year);
    url.searchParams.delete('id');

    // Keep search terms if they exist
    if (searchTerm) {
      if (searchTypeVal === 'keyword') {
        url.searchParams.set('keyword', searchTerm);
        url.searchParams.delete('vendor');
      } else if (searchTypeVal === 'vendor') {
        url.searchParams.set('vendor', searchTerm);
        url.searchParams.delete('keyword');
      } else {
        // For CVE ID, we don't keep other parameters
        url.searchParams.delete('vendor');
        url.searchParams.delete('keyword');
      }
    } else {
      // No search term, remove both
      url.searchParams.delete('vendor');
      url.searchParams.delete('keyword');
    }

    window.history.pushState({}, '', url);

    // Build API URL with all filters using centralized function
    let apiUrl = buildApiUrl('/api/cve-combined.php', filters);

    // Add keyword or vendor if we have a search term
    if (searchTerm) {
      if (searchTypeVal === 'keyword') {
        apiUrl += `&keyword=${encodeURIComponent(searchTerm)}`;
      } else if (searchTypeVal === 'vendor') {
        apiUrl += `&vendor=${encodeURIComponent(searchTerm)}`;
      }
    }

    console.log(`Fetching CVEs for year ${year} with all filters:`, filters);

    // Use the correct API path with relative URL
    fetch(apiUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        hideLoading();

        // Debug data structure in more detail
        if (data && typeof data === 'object') {
          console.log('Data keys:', Object.keys(data));
          if (data.vulnerabilities) {
            console.log('Vulnerabilities count:', data.vulnerabilities.length);
          }
        }

        if (data.error) {
          console.error('Error in API response:', data.message);
          showError(data.message || 'Error fetching CVE data');
          return;
        }

        if (data.vulnerabilities && data.vulnerabilities.length > 0) {
          currentCVEs = data.vulnerabilities;
          console.log(`Found ${currentCVEs.length} CVEs for year ${year}`);
          renderResults();
          updateStats();
        } else {
          console.warn(`No CVEs found for year ${year}`);
          showError(`No CVEs found for ${year}. Try a different year or other search criteria.`);
          resetStatCounters();
        }
      })
      .catch(error => {
        console.error('Error fetching CVEs:', error);
        hideLoading();
        showError('Failed to fetch CVE data. Please try again later.');
        resetStatCounters();
      });
  }
  
  /**
   * Fetches the most recent CVEs
   */
  function fetchRecentCVEs() {
    showLoading();

    // Get all current filters
    const filters = getCurrentFilters();

    // Update URL parameter to indicate we're viewing recent CVEs
    const url = new URL(window.location);
    
    // Only clear search-related parameters, keep filters if they exist
    url.searchParams.delete('id');
    url.searchParams.delete('vendor');
    url.searchParams.delete('keyword');
    
    // Keep year and severity filters if the user has set them
    // This allows for combined filtering (e.g., recent + critical severity)
    if (!filters.year) {
      url.searchParams.delete('year');
    }
    
    url.searchParams.set('view', 'recent');

    // Clear only the search input, not the filters
    searchInput.value = '';

    window.history.pushState({}, '', url);

    // Build the API URL with all filters using centralized function
    let apiUrl = buildApiUrl('/api/cve-combined.php', filters);
    
    // Add the recent parameter
    apiUrl += `&recent=true`;

    console.log('Fetching recent CVEs with filters:', filters);

    fetch(apiUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        hideLoading();

        if (data.error) {
          showError(data.message || 'Error fetching CVE data');
          return;
        }

        if (data.vulnerabilities && data.vulnerabilities.length > 0) {
          currentCVEs = data.vulnerabilities;
          renderResults();
          updateStats();
        } else {
          showError('No recent CVEs found');
          resetStatCounters();
        }
      })
      .catch(error => {
        console.error('Error fetching recent CVEs:', error);
        hideLoading();
        showError('Failed to fetch recent CVE data. Please try again later.');
        resetStatCounters();
      });
  }

  /**
   * Searches for CVEs by keyword in their descriptions
   */
  function searchByKeyword(keyword) {
    showLoading();

    // Get all current filters
    const filters = getCurrentFilters();

    // Update URL parameter to indicate we're searching by keyword
    // Keep all other parameters to enable combined searches
    const url = new URL(window.location);
    if (filters.year) {
      url.searchParams.set('year', filters.year);
    } else {
      url.searchParams.delete('year');
    }
    url.searchParams.delete('id');
    url.searchParams.delete('view');
    url.searchParams.set('keyword', keyword);

    // Clear any vendor parameter since we're doing a keyword search
    url.searchParams.delete('vendor');

    // Apply the URL update
    window.history.pushState({}, '', url);

    // Build the API request URL with all filters using centralized function
    let apiUrl = buildApiUrl('/api/cve-combined.php', filters);
    
    // Add the keyword parameter
    apiUrl += `&keyword=${encodeURIComponent(keyword)}`;

    console.log('Searching by keyword:', keyword);
    console.log('Fetching with URL:', apiUrl);
    console.log('All filters applied:', filters);

    // Fetch CVEs with the keyword and filters
    console.log(`Sending keyword search request for "${keyword}" with all current filters`);

    fetch(apiUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        hideLoading();

        // Log debug info if available

        // Do a more thorough check of the data structure
        if (!data || typeof data !== 'object') {
          console.error('Invalid response data format', data);
          showError('Invalid data format from server');
          return;
        }

        if (data.error) {
          console.error('Error in response:', data.error);
          showError(data.message || 'Error fetching CVE data');
          return;
        }

        // Use a more defensive check for vulnerabilities array
        if (data.vulnerabilities && Array.isArray(data.vulnerabilities) && data.vulnerabilities.length > 0) {
          currentCVEs = data.vulnerabilities;

          // Force re-render of results and update stats
          try {
            renderResults();
            updateStats();
          } catch (err) {
            console.error('Error rendering results:', err);
            showError('Error rendering search results');
          }
        } else {
          console.warn(`No results found for keyword "${keyword}"`);
          showError(`No CVEs found containing "${keyword}"`);
          resetStatCounters();
          // Clear existing results
          cveResults.innerHTML = '';
        }
      })
      .catch(error => {
        console.error('Error fetching CVEs by keyword:', error);
        hideLoading();
        showError('Failed to fetch CVE data. Please try again later.');
        resetStatCounters();
      });
  }

  /**
   * Searches for CVEs by vendor/product
   */
  function searchByVendor(vendor) {
    showLoading();

    // Get all current filters
    const filters = getCurrentFilters();

    // Update URL parameter to indicate we're searching by vendor
    // Keep all other parameters to enable combined searches
    const url = new URL(window.location);
    if (filters.year) {
      url.searchParams.set('year', filters.year);
    } else {
      url.searchParams.delete('year');
    }
    url.searchParams.delete('id');
    url.searchParams.delete('view');
    url.searchParams.set('vendor', vendor);

    // Clear any keyword parameter since we're doing a vendor search
    url.searchParams.delete('keyword');

    // Apply the URL update
    window.history.pushState({}, '', url);

    // Build the API request URL with all filters using centralized function
    let apiUrl = buildApiUrl('/api/cve-combined.php', filters);
    
    // Add the vendor parameter
    apiUrl += `&vendor=${encodeURIComponent(vendor)}`;

    console.log('Searching by vendor:', vendor);
    console.log('Fetching with URL:', apiUrl);
    console.log('All filters applied:', filters);

    // Fetch CVEs with the vendor and filters
    console.log(`Sending vendor search request for "${vendor}" with all current filters`);

    fetch(apiUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        hideLoading();

        // Log debug info if available

        // Do a more thorough check of the data structure
        if (!data || typeof data !== 'object') {
          console.error('Invalid response data format', data);
          showError('Invalid data format from server');
          return;
        }

        if (data.error) {
          console.error('Error in response:', data.error);
          showError(data.message || 'Error fetching CVE data');
          return;
        }

        // Use a more defensive check for vulnerabilities array
        if (data.vulnerabilities && Array.isArray(data.vulnerabilities) && data.vulnerabilities.length > 0) {
          currentCVEs = data.vulnerabilities;

          // Force re-render of results and update stats
          try {
            renderResults();
            updateStats();
          } catch (err) {
            console.error('Error rendering results:', err);
            showError('Error rendering search results');
          }
        } else {
          console.warn(`No results found for vendor "${vendor}"`);
          showError(`No CVEs found for vendor "${vendor}"`);
          resetStatCounters();
          // Clear existing results
          cveResults.innerHTML = '';
        }
      })
      .catch(error => {
        console.error('Error fetching CVEs by vendor:', error);
        hideLoading();
        showError('Failed to fetch CVE data. Please try again later.');
        resetStatCounters();
      });
  }

  /**
   * Filters the current results based on applied filters
   */
  function filterResults() {
    let filteredCVEs = [...currentCVEs];
    
    // Apply severity filter if set
    if (appliedFilters.severity) {
      filteredCVEs = filteredCVEs.filter(vuln => {
        const metrics = vuln.cve.metrics;
        if (!metrics) return false;
        
        // Check in both CVSS V3 and V2 metrics
        const cvssV3 = metrics.cvssMetricV31 || metrics.cvssMetricV30;
        const cvssV2 = metrics.cvssMetricV2;
        
        if (cvssV3 && cvssV3.length > 0) {
          return cvssV3[0].cvssData.baseSeverity === appliedFilters.severity;
        } else if (cvssV2 && cvssV2.length > 0) {
          return cvssV2[0].baseSeverity === appliedFilters.severity;
        }
        
        return false;
      });
    }
    
    // Render the filtered results
    renderFilteredResults(filteredCVEs);
  }
  
  /**
   * Renders the filtered results
   */
  function renderFilteredResults(filteredCVEs) {
    if (filteredCVEs.length === 0) {
      cveResults.innerHTML = `<div class="text-center p-4">No results match the selected filters</div>`;
      return;
    }
    
    renderCVECards(filteredCVEs);
  }
  
  /**
   * Renders the CVE results as cards
   */
  function renderResults() {
    // Clear current results
    cveResults.innerHTML = '';
    errorMessage.style.display = 'none';


    if (!currentCVEs || !Array.isArray(currentCVEs) || currentCVEs.length === 0) {
      // Show a more helpful message for no results
      cveResults.innerHTML = `
        <div class="text-center p-4">
          <i class="fa-solid fa-search fa-2x mb-3 text-muted"></i>
          <h4>No results found</h4>
          <p class="text-muted">Try a different search term, year, or filter</p>
        </div>`;
      resetStatCounters();
      return;
    }

    // No need for client-side sorting anymore, the API handles it
    renderCVECards(currentCVEs);
  }
  
  /**
   * Renders CVE cards from the provided array
   */
  function renderCVECards(cves) {
    cveResults.innerHTML = '';

    if (!cves || !Array.isArray(cves)) {
      console.error('Invalid CVEs array provided to renderCVECards:', cves);
      showError('Error rendering results: invalid data format');
      return;
    }

    cves.forEach((vuln, index) => {
      if (!vuln || !vuln.cve) {
        console.warn(`Skipping invalid CVE item at index ${index}:`, vuln);
        return;
      }

      const cve = vuln.cve;
      if (!cve) return;
      
      // Get severity info
      const severityInfo = getSeverityInfo(cve);
      
      // Create the card
      const card = document.createElement('div');
      card.className = 'cve-card';
      card.dataset.cveId = cve.id;
      
      // Get source indicators
      const sourceIndicators = getSourceIndicators(cve);

      // Check if this is in CISA KEV catalog
      const isKEV = cve.cisaData || (cve.source === 'CISA' || (cve.reportingAgencies && cve.reportingAgencies.includes('CISA')));

      // Create card content
      card.innerHTML = `
        <div class="cve-card-header">
          <h5 class="cve-card-title">${cve.id}</h5>
          <div class="d-flex align-items-center">
            ${isKEV ? `<span class="kev-indicator me-1"><i class="fa-solid fa-bolt"></i> Exploited</span>` : ''}
            <span class="severity-badge severity-${severityInfo.severity}">${severityInfo.severity}</span>
          </div>
        </div>
        <div class="cve-card-body">
          <p class="cve-card-description">${getDescription(cve)}</p>
          ${severityInfo.score ? `<div class="text-center mb-3">
            <span class="badge bg-secondary">Base Score: ${severityInfo.score}</span>
          </div>` : ''}
          <div class="d-flex justify-content-center">
            ${sourceIndicators}
          </div>
        </div>
        <div class="cve-card-footer">
          <span>Published: ${formatDate(cve.published)}</span>
          <span><i class="fa-solid fa-arrow-right"></i></span>
        </div>
      `;
      
      // Add click event
      card.addEventListener('click', () => {
        showCVEDetail(cve);
      });
      
      cveResults.appendChild(card);
    });
  }
  
  /**
   * Shows the detail modal for a specific CVE
   */
  function showCVEDetail(cve) {
    // Set the modal title
    cveDetailTitle.textContent = cve.id;
    
    // Get severity info
    const severityInfo = getSeverityInfo(cve);
    
    // Format the publication and last modified dates
    const published = formatDate(cve.published);
    const lastModified = formatDate(cve.lastModified);

    // Get source indicators
    const sourceIndicators = getSourceIndicators(cve);

    // Check if this is in CISA KEV catalog
    const isKEV = cve.cisaData || (cve.source === 'CISA' || (cve.reportingAgencies && cve.reportingAgencies.includes('CISA')));
    
    // Build references list with priority for important sources
    let referencesHtml = '';
    if (cve.references && cve.references.length > 0) {
      // Function to determine the reference source type
      const getSourceType = (url) => {
        if (url.includes('cve.mitre.org')) return 'MITRE';
        if (url.includes('nvd.nist.gov')) return 'NIST NVD';
        if (url.includes('cisa.gov')) return 'CISA';
        if (url.includes('cert.org')) return 'CERT';
        if (url.includes('kb.cert.org')) return 'CERT KB';
        if (url.includes('microsoft.com')) return 'Microsoft';
        if (url.includes('oracle.com')) return 'Oracle';
        if (url.includes('apple.com')) return 'Apple';
        if (url.includes('redhat.com')) return 'Red Hat';
        if (url.includes('debian.org')) return 'Debian';
        if (url.includes('ubuntu.com')) return 'Ubuntu';
        if (url.includes('github.com')) return 'GitHub';
        if (url.includes('exploit-db.com')) return 'Exploit-DB';
        return 'Source';
      };

      // Sort references to prioritize important sources
      const sortedRefs = [...cve.references].sort((a, b) => {
        const sourceA = getSourceType(a.url);
        const sourceB = getSourceType(b.url);

        // Define priority order for common sources
        const priority = {
          'MITRE': 1,
          'NIST NVD': 2,
          'CISA': 3,
          'CERT': 4,
          'CERT KB': 5
        };

        return (priority[sourceA] || 100) - (priority[sourceB] || 100);
      });

      referencesHtml = '<div class="cve-references">' +
        sortedRefs.map(ref => {
          const sourceType = getSourceType(ref.url);
          const sourceLabel = sourceType !== 'Source' ?
            `<span class="badge bg-primary me-2">${sourceType}</span>` : '';

          return `
            <div class="cve-reference">
              ${sourceLabel}
              <a href="${ref.url}" target="_blank" rel="noopener noreferrer">
                ${ref.url.length > 70 ? ref.url.substring(0, 67) + '...' : ref.url}
              </a>
            </div>
          `;
        }).join('') +
        '</div>';
    }
    
    // Set external link
    cveExternalLink.href = `https://nvd.nist.gov/vuln/detail/${cve.id}`;
    
    // Build the modal content
    cveDetailContent.innerHTML = `
      <div class="cve-detail-header">
        <div class="d-flex align-items-center">
          <h4>${cve.id}</h4>
          <div class="d-flex gap-2 align-items-center">
            ${isKEV ? `<span class="kev-indicator"><i class="fa-solid fa-bolt"></i> Actively Exploited</span>` : ''}
            <span class="severity-badge severity-${severityInfo.severity}">${severityInfo.severity}</span>
          </div>
        </div>
        <div class="d-flex justify-content-between align-items-center mt-2">
          <div class="text-muted">
            <small>Published: ${published} | Last Modified: ${lastModified}</small>
          </div>
          <div class="d-flex gap-1">
            ${sourceIndicators}
          </div>
        </div>
      </div>

      <div class="cve-detail-section">
        <h6>Description</h6>
        <p>${getDescription(cve)}</p>
      </div>

      ${isKEV && cve.cisaData ? `
      <div class="cve-detail-section">
        <h6>CISA Known Exploited Vulnerability Data</h6>
        <div class="alert alert-danger">
          <strong><i class="fa-solid fa-exclamation-triangle"></i> This vulnerability is being actively exploited in the wild</strong>
        </div>
        <table class="table table-dark table-sm">
          <tr>
            <th>Vendor/Project</th>
            <td>${cve.cisaData.vendorProject || 'N/A'}</td>
          </tr>
          <tr>
            <th>Product</th>
            <td>${cve.cisaData.product || 'N/A'}</td>
          </tr>
          <tr>
            <th>Required Action</th>
            <td>${cve.cisaData.requiredAction || 'N/A'}</td>
          </tr>
          <tr>
            <th>Due Date</th>
            <td>${formatDate(cve.cisaData.dueDate) || 'N/A'}</td>
          </tr>
          <tr>
            <th>Known Ransomware Use</th>
            <td>${cve.cisaData.knownRansomwareCampaignUse || 'Unknown'}</td>
          </tr>
        </table>
      </div>
      ` : ''}
      
      ${severityInfo.cvssV3 ? `
      <div class="cve-detail-section">
        <h6>CVSS v3 Metrics</h6>
        <div class="impact-indicators">
          <div class="impact-indicator">
            <div class="score">${severityInfo.score}</div>
            <div class="label">Base Score</div>
          </div>
          <div class="impact-indicator">
            <div class="score">${severityInfo.cvssV3.impactScore || 'N/A'}</div>
            <div class="label">Impact</div>
          </div>
          <div class="impact-indicator">
            <div class="score">${severityInfo.cvssV3.exploitabilityScore || 'N/A'}</div>
            <div class="label">Exploitability</div>
          </div>
        </div>
        <div class="mt-3">
          <code>${severityInfo.cvssV3.vectorString}</code>
        </div>
      </div>
      ` : ''}
      
      ${severityInfo.cvssV2 ? `
      <div class="cve-detail-section">
        <h6>CVSS v2 Metrics</h6>
        <div class="impact-indicators">
          <div class="impact-indicator">
            <div class="score">${severityInfo.cvssV2.baseScore}</div>
            <div class="label">Base Score</div>
          </div>
          <div class="impact-indicator">
            <div class="score">${severityInfo.cvssV2.impactScore || 'N/A'}</div>
            <div class="label">Impact</div>
          </div>
          <div class="impact-indicator">
            <div class="score">${severityInfo.cvssV2.exploitabilityScore || 'N/A'}</div>
            <div class="label">Exploitability</div>
          </div>
        </div>
        <div class="mt-3">
          <code>${severityInfo.cvssV2.vectorString}</code>
        </div>
      </div>
      ` : ''}
      
      ${referencesHtml ? `
      <div class="cve-detail-section">
        <h6>References</h6>
        ${referencesHtml}
      </div>
      ` : ''}
    `;
    
    // Show the modal
    detailModal.show();
  }
  
  /**
   * Updates the statistics counters
   */
  function updateStats() {
    let counts = {
      total: currentCVEs.length,
      critical: 0,
      high: 0,
      medium: 0
    };
    
    // Count by severity
    currentCVEs.forEach(vuln => {
      const cve = vuln.cve;
      if (!cve) return;
      
      const severityInfo = getSeverityInfo(cve);
      
      switch(severityInfo.severity) {
        case 'CRITICAL':
          counts.critical++;
          break;
        case 'HIGH':
          counts.high++;
          break;
        case 'MEDIUM':
        case 'LOW':
          counts.medium++;
          break;
      }
    });
    
    // Update counters
    totalCount.textContent = counts.total;
    criticalCount.textContent = counts.critical;
    highCount.textContent = counts.high;
    mediumCount.textContent = counts.medium;
  }
  
  /**
   * Resets the statistics counters
   */
  function resetStatCounters() {
    totalCount.textContent = '-';
    criticalCount.textContent = '-';
    highCount.textContent = '-';
    mediumCount.textContent = '-';
  }
  
  /**
   * Resets all filters and search parameters
   * Only used when we need to completely clear the state
   */
  function resetAllFilters() {
    // Reset DOM elements
    yearFilter.value = '';
    severityFilter.value = '';
    searchInput.value = '';
    
    // Reset source checkboxes to default (all selected)
    if (sourceFilters) {
      const checkboxes = sourceFilters.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        checkbox.checked = true;
      });
    }
  }
  
  /**
   * Gets severity information for a CVE with better error handling
   */
  function getSeverityInfo(cve) {
    const result = {
      severity: 'N/A',
      score: null,
      cvssV3: null,
      cvssV2: null
    };

    // Handle missing metrics
    if (!cve.metrics) {
      // If this is a CISA CVE, default to Critical (since all CISA KEVs are exploited)
      if (cve.source === 'CISA' || (cve.reportingAgencies && cve.reportingAgencies.includes('CISA'))) {
        result.severity = 'CRITICAL';
        result.score = 9.8; // Default high score for known exploited vulnerabilities
      }
      return result;
    }

    // Try CVSS v3.1
    const cvssV31 = cve.metrics.cvssMetricV31;
    if (cvssV31 && cvssV31.length > 0) {
      const metric = cvssV31[0];
      if (metric.cvssData) {
        result.severity = metric.cvssData.baseSeverity || 'HIGH';
        result.score = metric.cvssData.baseScore || 7.5;
        result.cvssV3 = metric.cvssData;

        // Add impact and exploitability scores if not present
        if (!result.cvssV3.impactScore && metric.impactScore) {
          result.cvssV3.impactScore = metric.impactScore;
        } else if (!result.cvssV3.impactScore) {
          result.cvssV3.impactScore = 5.9; // Default value
        }

        if (!result.cvssV3.exploitabilityScore && metric.exploitabilityScore) {
          result.cvssV3.exploitabilityScore = metric.exploitabilityScore;
        } else if (!result.cvssV3.exploitabilityScore) {
          result.cvssV3.exploitabilityScore = 3.9; // Default value
        }

        return result;
      }
    }

    // Try CVSS v3.0
    const cvssV30 = cve.metrics.cvssMetricV30;
    if (cvssV30 && cvssV30.length > 0) {
      const metric = cvssV30[0];
      if (metric.cvssData) {
        result.severity = metric.cvssData.baseSeverity || 'HIGH';
        result.score = metric.cvssData.baseScore || 7.5;
        result.cvssV3 = metric.cvssData;

        // Add impact and exploitability scores if not present
        if (!result.cvssV3.impactScore && metric.impactScore) {
          result.cvssV3.impactScore = metric.impactScore;
        } else if (!result.cvssV3.impactScore) {
          result.cvssV3.impactScore = 5.9; // Default value
        }

        if (!result.cvssV3.exploitabilityScore && metric.exploitabilityScore) {
          result.cvssV3.exploitabilityScore = metric.exploitabilityScore;
        } else if (!result.cvssV3.exploitabilityScore) {
          result.cvssV3.exploitabilityScore = 3.9; // Default value
        }

        return result;
      }
    }

    // Fall back to CVSS v2
    const cvssV2 = cve.metrics.cvssMetricV2;
    if (cvssV2 && cvssV2.length > 0) {
      const metric = cvssV2[0];
      if (metric.cvssData) {
        result.severity = metric.baseSeverity || 'HIGH';
        result.score = metric.cvssData.baseScore || 7.5;
        result.cvssV2 = metric.cvssData;

        // Add impact and exploitability scores if not present
        if (!result.cvssV2.impactScore && metric.impactScore) {
          result.cvssV2.impactScore = metric.impactScore;
        } else if (!result.cvssV2.impactScore) {
          result.cvssV2.impactScore = 6.4; // Default value
        }

        if (!result.cvssV2.exploitabilityScore && metric.exploitabilityScore) {
          result.cvssV2.exploitabilityScore = metric.exploitabilityScore;
        } else if (!result.cvssV2.exploitabilityScore) {
          result.cvssV2.exploitabilityScore = 8.6; // Default value
        }

        return result;
      }
    }

    // For CISA data, default to high severity if no metrics found
    if (cve.source === 'CISA' || (cve.reportingAgencies && cve.reportingAgencies.includes('CISA'))) {
      result.severity = 'HIGH';
      result.score = 8.0;
    }

    return result;
  }
  
  /**
   * Gets a user-friendly description for a CVE
   */
  function getDescription(cve) {
    if (!cve.descriptions || cve.descriptions.length === 0) {
      return 'No description available';
    }
    
    // Find English description
    const englishDesc = cve.descriptions.find(desc => desc.lang === 'en');
    return englishDesc ? englishDesc.value : cve.descriptions[0].value;
  }
  
  /**
   * Formats a date string to locale format
   */
  function formatDate(dateString) {
    if (!dateString) return 'N/A';

    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  }

  /**
   * Generates HTML for source indicators
   */
  function getSourceIndicators(cve) {
    const sources = [];

    // Check for explicit source field
    if (cve.source) {
      sources.push(cve.source);
    }

    // Check for reporting agencies array
    if (cve.reportingAgencies && Array.isArray(cve.reportingAgencies)) {
      cve.reportingAgencies.forEach(agency => {
        if (!sources.includes(agency)) {
          sources.push(agency);
        }
      });
    }

    // Default to NVD if no source info
    if (sources.length === 0) {
      sources.push('NVD');
    }

    // Convert to HTML
    return sources.map(source => {
      const sourceClass = source.toLowerCase().includes('nvd') ? 'nvd' :
                         source.toLowerCase().includes('mitre') ? 'mitre' :
                         source.toLowerCase().includes('cisa') ? 'cisa' : 'nvd';

      return `<span class="source-indicator source-${sourceClass}">${source}</span>`;
    }).join('');
  }
  
  /**
   * Shows the loading indicator
   */
  function showLoading() {
    loadingIndicator.style.display = 'block';
    cveResults.style.display = 'none';
    errorMessage.style.display = 'none';
  }
  
  /**
   * Hides the loading indicator
   */
  function hideLoading() {
    loadingIndicator.style.display = 'none';
    cveResults.style.display = 'grid';
  }
  
  /**
   * Shows an error message
   */
  function showError(message) {
    errorMessage.style.display = 'block';
    errorMessage.querySelector('p').textContent = message;
    cveResults.style.display = 'none';
  }
  
  // Initialize the dashboard
  initDashboard();
});
<?php
/**
 * Combined CVE API
 * 
 * This endpoint aggregates CVE data from multiple sources:
 * 1. NVD (National Vulnerability Database)
 * 2. MITRE CVE List
 * 3. CISA Known Exploited Vulnerabilities (KEV) Catalog
 * 
 * It merges and normalizes the data to provide a comprehensive view
 * of vulnerabilities with enriched metadata from all sources.
 */

// Set security headers
header('Content-Type: application/json');
header('X-Content-Type-Options: nosniff');
header('X-Frame-Options: DENY');
header('Referrer-Policy: strict-origin-when-cross-origin');
header('X-XSS-Protection: 1; mode=block');

// Enable CORS (same as other API endpoints)
$allowedOrigins = [
    'https://zeronexus.net',
    'https://www.zeronexus.net',
    'http://localhost:8081' // For local development
];

$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : '';

// Check if origin is allowed or is a subdomain of zeronexus.net
$isAllowed = in_array($origin, $allowedOrigins);
if (!$isAllowed && preg_match('/^https?:\/\/.*\.zeronexus\.net(:[0-9]+)?$/', $origin)) {
    $isAllowed = true;
}

if ($isAllowed) {
    header("Access-Control-Allow-Origin: $origin");
    header('Access-Control-Allow-Methods: GET, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type, CF-Connecting-IP, CF-IPCountry, CF-Ray, CF-Visitor, X-Forwarded-For, X-Forwarded-Proto');
    header('Vary: Origin');
}

// Exit on OPTIONS request (preflight)
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    exit(0);
}

// Apply rate limiting
require_once __DIR__ . '/rate-limit.php';
checkRateLimit('cve_combined');

// Get request parameters
$cveId = isset($_GET['id']) ? trim($_GET['id']) : null;
$year = isset($_GET['year']) ? intval($_GET['year']) : null;
$keyword = isset($_GET['keyword']) ? trim($_GET['keyword']) : null;
$vendor = isset($_GET['vendor']) ? trim($_GET['vendor']) : null;
$severity = isset($_GET['severity']) ? trim($_GET['severity']) : null;
$recent = isset($_GET['recent']) ? filter_var($_GET['recent'], FILTER_VALIDATE_BOOLEAN) : false;
$resultsPerPage = isset($_GET['resultsPerPage']) ? min(100, max(1, intval($_GET['resultsPerPage']))) : 50;
$sortOrder = isset($_GET['sort']) ? trim($_GET['sort']) : 'date_desc';

// Validate sort order
$validSortOrders = ['date_desc', 'date_asc'];
if (!in_array($sortOrder, $validSortOrders)) {
    $sortOrder = 'date_desc';
}

// Log all search parameters for debugging
error_log("=== CVE-COMBINED API CALL ===");
error_log("ID: " . ($cveId ?? 'none'));
error_log("Year: " . ($year ?? 'none'));
error_log("Keyword: " . ($keyword ?? 'none'));
error_log("Vendor: " . ($vendor ?? 'none'));
error_log("Severity: " . ($severity ?? 'none'));
error_log("Recent: " . ($recent ? 'true' : 'false'));
error_log("Results Per Page: " . $resultsPerPage);
error_log("Sort Order: " . $sortOrder);
error_log("Source Filter: " . (isset($_GET['sources']) ? $_GET['sources'] : 'all'));
error_log("==========================");

// Check for test mode
if (isset($_GET['test']) && $_GET['test'] === 'true') {
    // Return a test response with basic info
    echo json_encode([
        'status' => 'ok',
        'message' => 'API endpoint is functioning properly',
        'time' => date('c'),
        'php_version' => phpversion(),
        'server' => $_SERVER['SERVER_SOFTWARE'] ?? 'unknown',
        'params' => $_GET
    ]);
    exit;
}

// Optional parameter to specify which sources to include
$sources = isset($_GET['sources']) ? explode(',', $_GET['sources']) : ['nvd', 'mitre', 'cisa'];

// Clear cache if requested
if (isset($_GET['clearCache']) && $_GET['clearCache'] === 'true') {
    $cacheDirs = [
        sys_get_temp_dir() . '/zeronexus_combined_cache',
        sys_get_temp_dir() . '/zeronexus_cve_id_cache',
        sys_get_temp_dir() . '/zeronexus_cve_search_cache',
        sys_get_temp_dir() . '/zeronexus_cve_recent_cache',
        sys_get_temp_dir() . '/zeronexus_cve_keyword_cache',
        sys_get_temp_dir() . '/zeronexus_cve_vendor_cache',
        sys_get_temp_dir() . '/zeronexus_mitre_cache',
        sys_get_temp_dir() . '/zeronexus_cisa_cache'
    ];

    foreach ($cacheDirs as $dir) {
        if (is_dir($dir)) {
            $files = glob($dir . '/*');
            foreach ($files as $file) {
                if (is_file($file)) {
                    unlink($file);
                }
            }
        }
    }

    // Return success message
    echo json_encode([
        'success' => true,
        'message' => 'Cache cleared for all CVE APIs',
        'timestamp' => date('c')
    ]);
    exit;
}

// Check cache first for combined results
$cacheDir = sys_get_temp_dir() . '/zeronexus_combined_cache';
if (!is_dir($cacheDir)) {
    mkdir($cacheDir, 0755, true);
}

// Build cache key from all parameters
// IMPORTANT: Only include non-empty parameters in cache key to avoid pollution
$cacheParams = [];
if (!empty($cveId)) $cacheParams[] = "id_{$cveId}";
if (!empty($year)) $cacheParams[] = "year_{$year}";
if (!empty($keyword)) $cacheParams[] = "keyword_{$keyword}";
if (!empty($vendor)) $cacheParams[] = "vendor_{$vendor}";
if (!empty($severity)) $cacheParams[] = "severity_{$severity}";
if ($recent) $cacheParams[] = "recent_true";
$cacheParams[] = "rpp_{$resultsPerPage}";
$cacheParams[] = "sort_{$sortOrder}";
$cacheParams[] = "sources_" . implode('_', $sources);

$cacheKey = md5(implode('_', $cacheParams));
$cacheFile = $cacheDir . '/' . $cacheKey . '.json';
// Use a longer cache expiry to help with rate limiting
// Only bypass cache when explicitly requested with clearCache=true
$cacheExpiry = isset($_GET['clearCache']) && $_GET['clearCache'] === 'true' ? 0 : 12 * 60 * 60; // 12 hours cache for combined results

// Cache hit
if (file_exists($cacheFile) && (time() - filemtime($cacheFile)) < $cacheExpiry) {
    $cachedContent = file_get_contents($cacheFile);
    
    // Validate cache content matches current request parameters
    $cachedData = json_decode($cachedContent, true);
    if ($cachedData && isset($cachedData['debug_info'])) {
        $debugInfo = $cachedData['debug_info'];
        
        // Check if cached parameters match current request
        $cacheValid = true;
        
        // Check each parameter matches
        if ((empty($keyword) && !empty($debugInfo['keyword'])) || 
            (!empty($keyword) && $keyword !== $debugInfo['keyword'])) {
            $cacheValid = false;
            error_log("Cache mismatch on keyword: current='$keyword', cached='{$debugInfo['keyword']}'");
        }
        
        if ((empty($vendor) && !empty($debugInfo['vendor'])) || 
            (!empty($vendor) && $vendor !== $debugInfo['vendor'])) {
            $cacheValid = false;
            error_log("Cache mismatch on vendor: current='$vendor', cached='{$debugInfo['vendor']}'");
        }
        
        if ($cacheValid) {
            // Serve from cache
            header('X-Cache: HIT');
            echo $cachedContent;
            exit;
        } else {
            error_log("Cache validation failed, fetching fresh results");
        }
    }
}

// Initialize arrays to store results from each source
$results = [
    'nvd' => [],
    'mitre' => [],
    'cisa' => []
];

/**
 * Fetch data from NVD API
 */
function fetchFromNvd($params) {
    global $apiUrl, $queryParams, $fullUrl;

    // Use a direct request to NVD API instead of our proxy to simplify debugging
    // Set up the NVD API URL with appropriate parameters
    $apiUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0";

    // Add parameters
    $queryParams = [];

    // Handle specific parameters
    if (isset($params['id']) && !empty($params['id'])) {
        $queryParams['cveId'] = $params['id'];
    }

    // Current year
    $currentYear = date('Y');

    if (isset($params['year']) && !empty($params['year'])) {
        $year = $params['year'];

        // IMPORTANT: NVD API has a 120-day limit on date ranges
        // For a full year, we need to make multiple requests
        // For now, we'll request the most recent 120 days of the year
        // and rely on client-side filtering for complete accuracy
        
        // Calculate date ranges based on year
        if ($year == $currentYear) {
            // For current year, get from Jan 1 to today (or last 120 days if longer)
            $today = gmdate('Y-m-d\TH:i:s.000\Z');
            $startOfYear = $year . "-01-01T00:00:00.000Z";
            $daysFromStart = (time() - strtotime($startOfYear)) / 86400;
            
            if ($daysFromStart > 120) {
                // Get last 120 days
                $startDate = gmdate('Y-m-d\TH:i:s.000\Z', strtotime('-120 days'));
                $endDate = $today;
            } else {
                // Get from start of year
                $startDate = $startOfYear;
                $endDate = $today;
            }
        } else {
            // For past years, get the last 120 days of the year
            // This ensures we get the most recent CVEs from that year
            $startDate = $year . "-09-03T00:00:00.000Z"; // ~120 days before year end
            $endDate = $year . "-12-31T23:59:59.999Z";
        }
        
        $queryParams['pubStartDate'] = $startDate;
        $queryParams['pubEndDate'] = $endDate;
        
        error_log("Using date range for year {$year}: {$startDate} to {$endDate}");
        
        // Note: We'll still need client-side filtering to ensure only CVEs from the selected year are shown
        // This is because we can't fetch a full year's data in one request due to the 120-day limit
    } else if (isset($params['recent']) && $params['recent']) {
        // For recent CVEs, use date range for last 30 days
        $endDate = gmdate('Y-m-d\TH:i:s.000\Z');
        $startDate = gmdate('Y-m-d\TH:i:s.000\Z', strtotime('-30 days'));
        
        $queryParams['pubStartDate'] = $startDate;
        $queryParams['pubEndDate'] = $endDate;
        
        error_log("Using date range for recent CVEs: {$startDate} to {$endDate}");
    } else {
        // Default to last 30 days if no specific filters
        $endDate = gmdate('Y-m-d\TH:i:s.000\Z');
        $startDate = gmdate('Y-m-d\TH:i:s.000\Z', strtotime('-30 days'));
        
        $queryParams['pubStartDate'] = $startDate;
        $queryParams['pubEndDate'] = $endDate;
        
        error_log("Using default date range: {$startDate} to {$endDate}");
    }

    if (isset($params['keyword']) && !empty($params['keyword'])) {
        // Add keyword search to existing date filters
        $queryParams['keywordSearch'] = trim($params['keyword']);
        
        // If no date range was set yet, use a default range
        if (!isset($queryParams['pubStartDate'])) {
            // Default to last 2 years for keyword searches without specific date
            $endDate = gmdate('Y-m-d\TH:i:s.000\Z');
            $startDate = gmdate('Y-m-d\TH:i:s.000\Z', strtotime('-2 years'));
            $queryParams['pubStartDate'] = $startDate;
            $queryParams['pubEndDate'] = $endDate;
        }

        error_log("KEYWORD SEARCH: Adding keyword to existing filters");
        error_log("KEYWORD SEARCH PARAMS: " . json_encode($queryParams));
    }

    if (isset($params['vendor']) && !empty($params['vendor'])) {
        // Add vendor search to existing date filters
        // Note: vendor search uses keywordSearch parameter
        $queryParams['keywordSearch'] = trim($params['vendor']);
        
        // If no date range was set yet, use a default range
        if (!isset($queryParams['pubStartDate'])) {
            // Default to last 2 years for vendor searches without specific date
            $endDate = gmdate('Y-m-d\TH:i:s.000\Z');
            $startDate = gmdate('Y-m-d\TH:i:s.000\Z', strtotime('-2 years'));
            $queryParams['pubStartDate'] = $startDate;
            $queryParams['pubEndDate'] = $endDate;
        }

        error_log("VENDOR SEARCH: Adding vendor to existing filters");
        error_log("VENDOR SEARCH PARAMS: " . json_encode($queryParams));
    }

    if (isset($params['severity']) && !empty($params['severity'])) {
        $queryParams['cvssV3Severity'] = strtoupper($params['severity']);
    }

    // Set results per page - use a higher value to ensure we get enough results
    // Set this directly before building URL to make sure it's always included
    if (!isset($queryParams['resultsPerPage'])) {
        $queryParams['resultsPerPage'] = $params['resultsPerPage'] ?? 50;
    }
    
    // Build the full URL with query parameters
    $fullUrl = $apiUrl;
    if (!empty($queryParams)) {
        $fullUrl .= '?' . http_build_query($queryParams);
    }

    error_log("Fetching from NVD API: " . $fullUrl);
    
    // Make the request
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $fullUrl);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_TIMEOUT, 15);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'User-Agent: ZeroNexus-CVE-Tool/1.0'
    ]);
    
    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    $error = curl_error($ch);
    curl_close($ch);
    
    if ($error || $httpCode !== 200) {
        error_log("Error fetching from NVD: " . ($error ?: "HTTP {$httpCode}"));
        return null;
    }
    
    $data = json_decode($response, true);
    if ($data && isset($data['vulnerabilities'])) {
        // Add source metadata to each vulnerability
        foreach ($data['vulnerabilities'] as &$vuln) {
            if (isset($vuln['cve'])) {
                $vuln['cve']['source'] = 'NVD';
                
                // Add to reporting agencies
                if (!isset($vuln['cve']['reportingAgencies'])) {
                    $vuln['cve']['reportingAgencies'] = [];
                }
                
                if (!in_array('NVD', $vuln['cve']['reportingAgencies'])) {
                    $vuln['cve']['reportingAgencies'][] = 'NVD';
                }
            }
        }
        return $data;
    }
    
    return null;
}

/**
 * Fetch data from CISA KEV API
 */
function fetchFromCisa($params) {
    // Directly fetch from CISA's KEV catalog JSON feed
    $cisaKevUrl = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json";
    
    error_log("Fetching from CISA KEV: " . $cisaKevUrl);
    
    // Make the request
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $cisaKevUrl);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_TIMEOUT, 15);
    curl_setopt($ch, CURLOPT_HTTPHEADER, [
        'User-Agent: ZeroNexus-CVE-Tool/1.0'
    ]);
    
    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    $error = curl_error($ch);
    curl_close($ch);
    
    if ($error || $httpCode !== 200) {
        error_log("Error fetching from CISA: " . ($error ?: "HTTP {$httpCode}"));
        return null;
    }
    
    // Parse the CISA KEV data
    $kevData = json_decode($response, true);
    
    if (!$kevData || !isset($kevData['vulnerabilities']) || empty($kevData['vulnerabilities'])) {
        error_log("No valid CISA KEV data found");
        return null;
    }
    
    // Filter the vulnerabilities based on parameters
    $filteredVulns = $kevData['vulnerabilities'];
    
    // Filter by CVE ID if provided
    if (isset($params['id']) && !empty($params['id'])) {
        $cveId = strtoupper($params['id']);
        $filteredVulns = array_filter($filteredVulns, function($vuln) use ($cveId) {
            return strtoupper($vuln['cveID']) === $cveId;
        });
    }
    
    // Filter by year if provided
    if (isset($params['year']) && !empty($params['year'])) {
        $year = $params['year'];
        $filteredVulns = array_filter($filteredVulns, function($vuln) use ($year) {
            return strpos($vuln['cveID'], "CVE-{$year}-") === 0;
        });
    }
    
    // Filter by keyword if provided
    if (isset($params['keyword']) && !empty($params['keyword'])) {
        $keyword = strtolower($params['keyword']);
        error_log("CISA: Filtering by keyword: " . $keyword);
        $filteredVulns = array_filter($filteredVulns, function($vuln) use ($keyword) {
            return strpos(strtolower($vuln['vulnerabilityName']), $keyword) !== false ||
                  strpos(strtolower($vuln['product']), $keyword) !== false;
        });
    }
    
    // Filter by vendor if provided
    if (isset($params['vendor']) && !empty($params['vendor'])) {
        $vendor = strtolower($params['vendor']);
        error_log("CISA: Filtering by vendor: " . $vendor);
        $filteredVulns = array_filter($filteredVulns, function($vuln) use ($vendor) {
            return strpos(strtolower($vuln['vendorProject']), $vendor) !== false;
        });
    }
    
    // Reset array keys
    $filteredVulns = array_values($filteredVulns);
    
    // Convert to NVD format for consistency
    $vulnerabilities = [];
    foreach ($filteredVulns as $kev) {
        // Basic structure to match NVD format
        $vulnerability = [
            'cve' => [
                'id' => $kev['cveID'],
                'sourceIdentifier' => 'CISA',
                'published' => $kev['dateAdded'],
                'lastModified' => $kev['dateAdded'],
                'source' => 'CISA',
                'reportingAgencies' => ['CISA'],
                'vulnStatus' => 'Known Exploited',
                'descriptions' => [
                    [
                        'lang' => 'en',
                        'value' => $kev['vulnerabilityName']
                    ]
                ],
                'metrics' => [
                    'cvssMetricV31' => [
                        [
                            'cvssData' => [
                                'version' => '3.1',
                                'vectorString' => 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
                                'attackVector' => 'NETWORK',
                                'attackComplexity' => 'LOW',
                                'privilegesRequired' => 'NONE',
                                'userInteraction' => 'NONE',
                                'scope' => 'UNCHANGED',
                                'confidentialityImpact' => 'HIGH',
                                'integrityImpact' => 'HIGH',
                                'availabilityImpact' => 'HIGH',
                                'baseScore' => 9.8,
                                'baseSeverity' => 'CRITICAL'
                            ],
                            'exploitabilityScore' => 3.9,
                            'impactScore' => 5.9,
                            'acInsufInfo' => false,
                            'obtainAllPrivilege' => true,
                            'obtainUserPrivilege' => false,
                            'obtainOtherPrivilege' => false,
                            'userInteractionRequired' => false
                        ]
                    ]
                ],
                'references' => [
                    [
                        'url' => 'https://www.cisa.gov/known-exploited-vulnerabilities-catalog',
                        'source' => 'CISA',
                        'tags' => ['CISA KEV']
                    ]
                ],
                'cisaData' => [
                    'vendorProject' => $kev['vendorProject'],
                    'product' => $kev['product'],
                    'requiredAction' => $kev['requiredAction'],
                    'dueDate' => $kev['dueDate'],
                    'knownRansomwareCampaignUse' => isset($kev['knownRansomwareCampaignUse']) ? $kev['knownRansomwareCampaignUse'] : 'Unknown'
                ]
            ]
        ];
        
        $vulnerabilities[] = $vulnerability;
    }
    
    // Structure the response like NVD for consistency
    $result = [
        'resultsPerPage' => count($vulnerabilities),
        'startIndex' => 0,
        'totalResults' => count($vulnerabilities),
        'format' => 'CISA_KEV',
        'version' => '1.0',
        'timestamp' => date('c'),
        'vulnerabilities' => $vulnerabilities
    ];
    
    return $result;
}

/**
 * Merge vulnerabilities from multiple sources
 */
function mergeVulnerabilities($sources) {
    $mergedVulns = [];
    $cveIds = []; // Track CVE IDs for deduplication
    
    // Process each source
    foreach ($sources as $sourceName => $sourceData) {
        if (!$sourceData || !isset($sourceData['vulnerabilities'])) {
            continue;
        }
        
        // Log how many vulnerabilities this source contains
        error_log("Source {$sourceName} has " . count($sourceData['vulnerabilities']) . " vulnerabilities");
        
        foreach ($sourceData['vulnerabilities'] as $vuln) {
            if (!isset($vuln['cve']) || !isset($vuln['cve']['id'])) {
                continue;
            }
            
            $cveId = $vuln['cve']['id'];
            
            // If this CVE is already in our results, merge the data
            if (isset($cveIds[$cveId])) {
                $index = $cveIds[$cveId];
                $mergedVulns[$index] = mergeVulnerabilityData($mergedVulns[$index], $vuln, $sourceName);
            } else {
                // Add source attribute if not present
                if (!isset($vuln['cve']['source'])) {
                    $vuln['cve']['source'] = strtoupper($sourceName);
                }
                // Add source as reporting agency if not already present
                if (!isset($vuln['cve']['reportingAgencies'])) {
                    $vuln['cve']['reportingAgencies'] = [];
                }
                $vuln['cve']['reportingAgencies'][] = strtoupper($sourceName);
                
                // Add to merged results
                $mergedVulns[] = $vuln;
                $cveIds[$cveId] = count($mergedVulns) - 1;
            }
        }
    }
    
    error_log("Final merged CVE count: " . count($mergedVulns));
    return $mergedVulns;
}

/**
 * Merge data from two vulnerability objects, with better normalization
 */
function mergeVulnerabilityData($target, $source, $sourceName) {
    // If source has CISA data and target doesn't, add it
    if (isset($source['cve']['cisaData']) && !isset($target['cve']['cisaData'])) {
        $target['cve']['cisaData'] = $source['cve']['cisaData'];
    }

    // Add source to reporting agencies if not already present
    if (!isset($target['cve']['reportingAgencies'])) {
        $target['cve']['reportingAgencies'] = [];
    }
    if (!in_array(strtoupper($sourceName), $target['cve']['reportingAgencies'])) {
        $target['cve']['reportingAgencies'][] = strtoupper($sourceName);
    }

    // If this is CISA data, enhance the metrics with high/critical severity
    // if not available in the target data
    if (strtolower($sourceName) === 'cisa' && isset($source['cve']['metrics'])) {
        // Add/update CVSS metrics from CISA if not present in target
        if (!isset($target['cve']['metrics']) ||
            (!isset($target['cve']['metrics']['cvssMetricV31']) && !isset($target['cve']['metrics']['cvssMetricV3']))) {

            if (isset($source['cve']['metrics']['cvssMetricV31'])) {
                $target['cve']['metrics']['cvssMetricV31'] = $source['cve']['metrics']['cvssMetricV31'];
            } else if (isset($source['cve']['metrics']['cvssMetricV3'])) {
                $target['cve']['metrics']['cvssMetricV3'] = $source['cve']['metrics']['cvssMetricV3'];
            }
        }
    }

    // Make sure CVSS data is properly normalized
    if (isset($source['cve']['metrics'])) {
        if (!isset($target['cve']['metrics'])) {
            $target['cve']['metrics'] = [];
        }

        // Transfer metrics if target doesn't have them
        if (isset($source['cve']['metrics']['cvssMetricV31']) && !isset($target['cve']['metrics']['cvssMetricV31'])) {
            $target['cve']['metrics']['cvssMetricV31'] = $source['cve']['metrics']['cvssMetricV31'];
        }

        if (isset($source['cve']['metrics']['cvssMetricV30']) && !isset($target['cve']['metrics']['cvssMetricV30'])) {
            $target['cve']['metrics']['cvssMetricV30'] = $source['cve']['metrics']['cvssMetricV30'];
        }

        if (isset($source['cve']['metrics']['cvssMetricV2']) && !isset($target['cve']['metrics']['cvssMetricV2'])) {
            $target['cve']['metrics']['cvssMetricV2'] = $source['cve']['metrics']['cvssMetricV2'];
        }
    }

    // Merge references
    if (isset($source['cve']['references']) && !empty($source['cve']['references'])) {
        if (!isset($target['cve']['references'])) {
            $target['cve']['references'] = [];
        }

        // Add new references that don't already exist
        foreach ($source['cve']['references'] as $reference) {
            $exists = false;
            foreach ($target['cve']['references'] as $existingRef) {
                if ($existingRef['url'] === $reference['url']) {
                    $exists = true;
                    break;
                }
            }

            if (!$exists) {
                $target['cve']['references'][] = $reference;
            }
        }
    }

    return $target;
}

// Fetch data from each requested source
$requestParams = [
    'id' => $cveId,
    'year' => $year,
    'keyword' => $keyword,
    'vendor' => $vendor,
    'severity' => $severity,
    'recent' => $recent ? 'true' : '',
    'resultsPerPage' => $resultsPerPage
];

// Fetch from NVD if requested, with rate limit protection
if (in_array('nvd', $sources)) {
    // Check if we have a cached result that's reasonably fresh
    $nvdBackupPath = sys_get_temp_dir() . "/zeronexus_nvd_backup";
    $useCache = false;

    // Use cached data if it exists and is less than 6 hours old
    if (file_exists($nvdBackupPath) && (time() - filemtime($nvdBackupPath) < 6 * 3600)) {
        $cachedData = file_get_contents($nvdBackupPath);
        if ($cachedData) {
            $results['nvd'] = json_decode($cachedData, true);
            error_log("Using cached NVD data to avoid rate limiting");
            $useCache = true;
        }
    }

    // Only fetch live if we don't have cache or it's stale
    if (!$useCache) {
        $results['nvd'] = fetchFromNvd($requestParams);

        // Store successful results for future use
        if ($results['nvd'] && isset($results['nvd']['vulnerabilities']) && count($results['nvd']['vulnerabilities']) > 0) {
            file_put_contents($nvdBackupPath, json_encode($results['nvd']));
            error_log("Stored NVD result cache for future rate limit protection");
        }
    }

    // Log the results for debugging
    error_log("NVD results: " . ($results['nvd'] && isset($results['nvd']['vulnerabilities']) ? count($results['nvd']['vulnerabilities']) . " vulnerabilities" : "none"));
}

// Handle MITRE source (using NVD data but marked as from MITRE)
if (in_array('mitre', $sources)) {
    $mitreBackupPath = sys_get_temp_dir() . "/zeronexus_mitre_backup";
    $useMitreCache = false;

    // First, try to get data from NVD results if available
    if (isset($results['nvd']) && $results['nvd'] && isset($results['nvd']['vulnerabilities']) && count($results['nvd']['vulnerabilities']) > 0) {
        $results['mitre'] = $results['nvd'];
        $shouldUpdateMitreAttributes = true;
    }
    // Then try cached data if it's fresh enough
    else if (file_exists($mitreBackupPath) && (time() - filemtime($mitreBackupPath) < 6 * 3600)) {
        $cachedData = file_get_contents($mitreBackupPath);
        if ($cachedData) {
            $results['mitre'] = json_decode($cachedData, true);
            $shouldUpdateMitreAttributes = false; // Already have MITRE attributes
            error_log("Using cached MITRE data to avoid rate limiting");
            $useMitreCache = true;
        }
    }

    // As a last resort, fetch fresh data if we have no cache and no NVD data
    if (!isset($results['mitre']) || !$results['mitre']) {
        // Fetch fresh data with rate limiting protection
        $results['mitre'] = fetchFromNvd($requestParams);
        $shouldUpdateMitreAttributes = true;
    }

    // Update MITRE attribution if needed
    if (isset($shouldUpdateMitreAttributes) && $shouldUpdateMitreAttributes &&
        isset($results['mitre']) && $results['mitre'] &&
        isset($results['mitre']['vulnerabilities'])) {

        foreach ($results['mitre']['vulnerabilities'] as &$vuln) {
            if (isset($vuln['cve'])) {
                $vuln['cve']['source'] = 'MITRE';

                // Add to reporting agencies
                if (!isset($vuln['cve']['reportingAgencies'])) {
                    $vuln['cve']['reportingAgencies'] = [];
                }

                if (!in_array('MITRE', $vuln['cve']['reportingAgencies'])) {
                    $vuln['cve']['reportingAgencies'][] = 'MITRE';
                }

                // Add MITRE reference link if not present
                if (!isset($vuln['cve']['references'])) {
                    $vuln['cve']['references'] = [];
                }

                $hasMitreRef = false;
                foreach ($vuln['cve']['references'] as $ref) {
                    if (isset($ref['url']) && strpos($ref['url'], 'cve.mitre.org') !== false) {
                        $hasMitreRef = true;
                        break;
                    }
                }

                if (!$hasMitreRef && isset($vuln['cve']['id'])) {
                    $cveId = $vuln['cve']['id'];
                    $vuln['cve']['references'][] = [
                        'url' => "https://cve.mitre.org/cgi-bin/cvename.cgi?name={$cveId}",
                        'source' => 'MITRE',
                        'tags' => ['MITRE CVE']
                    ];
                }
            }
        }

        // Store successful results for future use
        if ($results['mitre'] && isset($results['mitre']['vulnerabilities']) && count($results['mitre']['vulnerabilities']) > 0) {
            file_put_contents($mitreBackupPath, json_encode($results['mitre']));
            error_log("Stored MITRE result cache for future rate limit protection");
        }
    }

    // Log the results for debugging
    error_log("MITRE results: " . ($results['mitre'] && isset($results['mitre']['vulnerabilities']) ? count($results['mitre']['vulnerabilities']) . " vulnerabilities" : "none"));
}

// Fetch from CISA if requested, with rate limit protection
if (in_array('cisa', $sources)) {
    // Check if we have cached CISA data
    $cisaBackupPath = sys_get_temp_dir() . "/zeronexus_cisa_backup";
    $useCisaCache = false;

    // CISA data changes less frequently, so we can use a longer cache expiry (12 hours)
    if (file_exists($cisaBackupPath) && (time() - filemtime($cisaBackupPath) < 12 * 3600)) {
        $cachedData = file_get_contents($cisaBackupPath);
        if ($cachedData) {
            $results['cisa'] = json_decode($cachedData, true);
            error_log("Using cached CISA data to avoid rate limiting");
            $useCisaCache = true;
        }
    }

    // Only fetch live if we don't have cache or it's stale
    if (!$useCisaCache) {
        $results['cisa'] = fetchFromCisa($requestParams);

        // Store successful results for future use
        if ($results['cisa'] && isset($results['cisa']['vulnerabilities']) && count($results['cisa']['vulnerabilities']) > 0) {
            file_put_contents($cisaBackupPath, json_encode($results['cisa']));
            error_log("Stored CISA result cache for future rate limit protection");
        }
    }

    // Log the results for debugging
    error_log("CISA results: " . ($results['cisa'] && isset($results['cisa']['vulnerabilities']) ? count($results['cisa']['vulnerabilities']) . " vulnerabilities" : "none"));
}

// Check if we encountered rate limiting issues
$rateLimit = false;
foreach ($results as $source => $data) {
    if ($data === null || (isset($data['error']) && strpos($data['error'], 'rate limit') !== false)) {
        $rateLimit = true;
        error_log("Rate limit hit for source: $source");

        // If we hit rate limits, try using cached data
        $cachePath = sys_get_temp_dir() . "/zeronexus_{$source}_backup";
        if (file_exists($cachePath)) {
            $cachedData = file_get_contents($cachePath);
            if ($cachedData) {
                $results[$source] = json_decode($cachedData, true);
                error_log("Using cached backup data for $source");
            }
        }
    } else if ($data && !isset($data['error'])) {
        // Store successful results as backup cache for future rate limit hits
        $cachePath = sys_get_temp_dir() . "/zeronexus_{$source}_backup";
        file_put_contents($cachePath, json_encode($data));
        error_log("Stored backup cache for $source");
    }
}

// Merge results from all sources
$mergedVulnerabilities = mergeVulnerabilities($results);

// Helper function to extract and normalize dates
function extractVulnerabilityDate($vuln) {
    $date = null;
    
    // Try to get date from published field first
    if (isset($vuln['cve']['published']) && !empty($vuln['cve']['published'])) {
        $date = $vuln['cve']['published'];
    } else if (isset($vuln['cve']['cisaData']['dateAdded']) && !empty($vuln['cve']['cisaData']['dateAdded'])) {
        $date = $vuln['cve']['cisaData']['dateAdded'];
    } else if (isset($vuln['cve']['lastModified']) && !empty($vuln['cve']['lastModified'])) {
        $date = $vuln['cve']['lastModified'];
    }
    
    // Try to parse the date with various formats
    if ($date) {
        // Handle ISO 8601 format with timezone
        if (preg_match('/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/', $date)) {
            $timestamp = strtotime($date);
            if ($timestamp !== false) {
                return $timestamp;
            }
        }
        
        // Handle date-only format (YYYY-MM-DD)
        if (preg_match('/^\d{4}-\d{2}-\d{2}$/', $date)) {
            $timestamp = strtotime($date . ' 00:00:00');
            if ($timestamp !== false) {
                return $timestamp;
            }
        }
        
        // Try generic strtotime as fallback
        $timestamp = strtotime($date);
        if ($timestamp !== false && $timestamp > 0) {
            return $timestamp;
        }
    }
    
    // If no valid date found, use Unix epoch as fallback
    return 0;
}

// Sort the merged vulnerabilities based on the sort order
if (!empty($mergedVulnerabilities)) {
    usort($mergedVulnerabilities, function($a, $b) use ($sortOrder) {
        // Extract dates using the helper function
        $dateA = extractVulnerabilityDate($a);
        $dateB = extractVulnerabilityDate($b);
        
        // If dates are equal, sort by CVE ID as secondary sort
        if ($dateA === $dateB) {
            $idA = isset($a['cve']['id']) ? $a['cve']['id'] : '';
            $idB = isset($b['cve']['id']) ? $b['cve']['id'] : '';
            return strcmp($idA, $idB);
        }
        
        // Sort based on the sort order
        if ($sortOrder === 'date_desc') {
            return $dateB - $dateA;
        } else {
            return $dateA - $dateB;
        }
    });
    
    error_log("Sorted " . count($mergedVulnerabilities) . " vulnerabilities by $sortOrder");
}

// If we have CISA results and other sources, ensure CISA isn't completely overwhelmed
if (in_array('cisa', $sources) && count($sources) > 1 && count($mergedVulnerabilities) > 0) {
    // Count how many results are from each source
    $sourceCounts = [];
    foreach ($mergedVulnerabilities as $vuln) {
        if (isset($vuln['cve']['source'])) {
            $source = strtolower($vuln['cve']['source']);
            $sourceCounts[$source] = ($sourceCounts[$source] ?? 0) + 1;
        }
    }

    // Log the source counts for debugging
    error_log("Source counts: " . json_encode($sourceCounts));

    // If CISA is less than 10% of results and we have CISA results available,
    // boost CISA representation by duplicating results if needed
    if (isset($sourceCounts['cisa']) &&
        isset($results['cisa']) &&
        isset($results['cisa']['vulnerabilities']) &&
        count($results['cisa']['vulnerabilities']) > 0) {

        $cisaCount = $sourceCounts['cisa'] ?? 0;
        $totalCount = count($mergedVulnerabilities);
        $cisaPercentage = ($cisaCount / $totalCount) * 100;

        if ($cisaPercentage < 10 && $cisaCount < $totalCount && $cisaCount > 0) {
            error_log("CISA results ($cisaCount) are less than 10% of total ($totalCount), boosting visibility");

            // Find CISA vulnerabilities in the merged results and prioritize them
            foreach ($mergedVulnerabilities as $key => $vuln) {
                if (isset($vuln['cve']['source']) && $vuln['cve']['source'] === 'CISA') {
                    // Move CISA results toward the front of the array
                    $temp = $vuln;
                    unset($mergedVulnerabilities[$key]);
                    array_unshift($mergedVulnerabilities, $temp);
                }
            }

            // Reset array keys after manipulation
            $mergedVulnerabilities = array_values($mergedVulnerabilities);
        }
    }
}

// Build final response
$response = [
    'resultsPerPage' => count($mergedVulnerabilities),
    'startIndex' => 0,
    'totalResults' => count($mergedVulnerabilities),
    'format' => 'COMBINED',
    'version' => '1.0',
    'timestamp' => date('c'),
    'sources' => array_keys(array_filter($results)),
    'vulnerabilities' => $mergedVulnerabilities,

    // Always include comprehensive debugging info to track search issues
    'debug_info' => [
        'keyword' => $keyword,
        'keyword_empty' => isset($keyword) && $keyword === '',
        'vendor' => $vendor,
        'vendor_empty' => isset($vendor) && $vendor === '',
        'year' => $year,
        'recent' => $recent,
        'severity' => $severity,
        'sources_requested' => $sources,
        'query_count' => count($mergedVulnerabilities),
        'timestamp' => date('c')
    ]
];

// Cache the response
file_put_contents($cacheFile, json_encode($response));

// Add debug information if requested
if (isset($_GET['debug']) && $_GET['debug'] === 'true') {
    $response['debug'] = [
        'raw_params' => $_GET,
        'processed_params' => $requestParams,
        'nvd_base_url' => $apiUrl ?? 'Not available',
        'nvd_params' => $queryParams ?? 'Not available',
        'nvd_full_url' => isset($fullUrl) ? $fullUrl : 'Not available',
        'executed_requests' => [
            'nvd_requested' => in_array('nvd', $sources),
            'mitre_requested' => in_array('mitre', $sources),
            'cisa_requested' => in_array('cisa', $sources),
        ],
        'php_version' => phpversion(),
        'server_time' => date('c')
    ];
}

// Output the response
header('X-Cache: MISS');
echo json_encode($response);
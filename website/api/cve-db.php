<?php
/**
 * CVE Database API
 * 
 * This endpoint provides local database access for CVE lookups, replacing external API dependencies.
 * All filtering and processing is done locally for maximum performance and reliability.
 * 
 * Parameters:
 * - id: A specific CVE ID (e.g., CVE-2023-12345)
 * - year: A year to search for CVEs (e.g., 2023)
 * - recent: true for recent CVEs (last 30 days)
 * - keyword: Search keyword in descriptions
 * - vendor: Search by vendor/product name
 * - severity: Filter by severity (CRITICAL, HIGH, MEDIUM, LOW)
 * - sources: Filter by data sources (nvd,mitre,cisa)
 * - resultsPerPage: Number of results (1-100, default 20)
 * - sort: Sort order (date_desc, date_asc, severity_desc)
 */

require_once __DIR__ . '/cve-database.php';

// Set security headers
header('Content-Type: application/json');
header('X-Content-Type-Options: nosniff');
header('X-Frame-Options: DENY');
header('Referrer-Policy: strict-origin-when-cross-origin');
header('X-XSS-Protection: 1; mode=block');

// Enable CORS for specific origins
$allowedOrigins = [
    'https://zeronexus.net',
    'https://www.zeronexus.net',
    'http://localhost:8081',
    'http://localhost:8082' // For local development
];

$origin = isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : '';

// Check if origin is allowed or is a subdomain of zeronexus.net
$isAllowed = in_array($origin, $allowedOrigins);
if (!$isAllowed && preg_match('/^https?:\/\/.*\.zeronexus\.net(:[0-9]+)?$/', $origin)) {
    $isAllowed = true;
}

if ($isAllowed) {
    header("Access-Control-Allow-Origin: $origin");
    header('Access-Control-Allow-Methods: GET, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type, CF-Connecting-IP, CF-IPCountry, CF-Ray, CF-Visitor, X-Forwarded-For, X-Forwarded-Proto');
    header('Vary: Origin');
}

// Exit on OPTIONS request (preflight)
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    exit(0);
}

// Rate limiting
function checkRateLimit() {
    $ip = isset($_SERVER['HTTP_CF_CONNECTING_IP']) ? $_SERVER['HTTP_CF_CONNECTING_IP'] : $_SERVER['REMOTE_ADDR'];
    $rateLimitFile = sys_get_temp_dir() . '/zeronexus_cve_db_rate_' . md5($ip);
    $currentTime = time();
    
    if (file_exists($rateLimitFile)) {
        $data = json_decode(file_get_contents($rateLimitFile), true);
        
        if ($currentTime - $data['timestamp'] > 60) {
            $data = ['count' => 1, 'timestamp' => $currentTime];
        } else {
            $data['count']++;
            
            // Higher rate limit since this is local database
            if ($data['count'] > 100) {
                http_response_code(429);
                echo json_encode(['error' => true, 'message' => 'Too many requests. Please try again later.']);
                exit;
            }
        }
    } else {
        $data = ['count' => 1, 'timestamp' => $currentTime];
    }
    
    file_put_contents($rateLimitFile, json_encode($data));
}

checkRateLimit();

try {
    // Initialize database
    $db = new CVEDatabase();
    
    // Get request parameters
    $cveId = isset($_GET['id']) ? trim($_GET['id']) : null;
    $year = isset($_GET['year']) ? intval($_GET['year']) : null;
    $recent = isset($_GET['recent']) ? filter_var($_GET['recent'], FILTER_VALIDATE_BOOLEAN) : false;
    $keyword = isset($_GET['keyword']) ? trim($_GET['keyword']) : null;
    $vendor = isset($_GET['vendor']) ? trim($_GET['vendor']) : null;
    $severity = isset($_GET['severity']) ? trim($_GET['severity']) : null;
    $sources = isset($_GET['sources']) ? explode(',', $_GET['sources']) : null;
    $resultsPerPage = isset($_GET['resultsPerPage']) ? min(100, max(1, intval($_GET['resultsPerPage']))) : 20;
    $sort = isset($_GET['sort']) ? $_GET['sort'] : 'date_desc';
    
    // Build filters array
    $filters = [
        'resultsPerPage' => $resultsPerPage,
        'sort' => $sort
    ];
    
    if ($cveId) {
        $filters['id'] = $cveId;
    }
    
    if ($year) {
        $filters['year'] = $year;
    }
    
    if ($recent) {
        $filters['recent'] = true;
    }
    
    if ($keyword) {
        $filters['keyword'] = $keyword;
    }
    
    if ($vendor) {
        $filters['vendor'] = $vendor;
    }
    
    if ($severity) {
        $filters['severity'] = $severity;
    }
    
    if ($sources) {
        $filters['sources'] = array_map('trim', $sources);
    }
    
    // Search CVEs
    $cves = $db->searchCVEs($filters);
    $stats = $db->getStats($filters);
    
    // Convert database results to NVD API format for compatibility
    $vulnerabilities = [];
    
    foreach ($cves as $cve) {
        // Parse raw JSON data if available, otherwise construct from database fields
        if (!empty($cve['raw_data_json'])) {
            $rawData = json_decode($cve['raw_data_json'], true);
            if ($rawData) {
                $vulnerabilities[] = ['cve' => $rawData];
                continue;
            }
        }
        
        // Construct CVE data from database fields
        $cveData = [
            'id' => $cve['cve_id'],
            'published' => $cve['published'],
            'lastModified' => $cve['modified'],
            'vulnStatus' => $cve['status'] ?: 'Published',
            'descriptions' => [
                [
                    'lang' => 'en',
                    'value' => $cve['description'] ?: 'No description available'
                ]
            ],
            'source' => $cve['source'] ?: 'NVD'
        ];
        
        // Add CVSS metrics if available
        if ($cve['cvss_v3_score'] || $cve['cvss_v2_score']) {
            $cveData['metrics'] = [];
            
            if ($cve['cvss_v3_score']) {
                $cveData['metrics']['cvssMetricV31'] = [
                    [
                        'cvssData' => [
                            'baseScore' => floatval($cve['cvss_v3_score']),
                            'baseSeverity' => $cve['cvss_v3_severity'],
                            'vectorString' => 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H' // Default vector
                        ],
                        'impactScore' => 5.9,
                        'exploitabilityScore' => 3.9
                    ]
                ];
            }
            
            if ($cve['cvss_v2_score']) {
                $cveData['metrics']['cvssMetricV2'] = [
                    [
                        'cvssData' => [
                            'baseScore' => floatval($cve['cvss_v2_score']),
                            'vectorString' => 'AV:N/AC:L/Au:N/C:P/I:P/A:P' // Default vector
                        ],
                        'baseSeverity' => $cve['cvss_v2_severity'],
                        'impactScore' => 6.4,
                        'exploitabilityScore' => 8.6
                    ]
                ];
            }
        }
        
        // Add CISA data if available
        if ($cve['cisa_exploited']) {
            $cveData['cisaData'] = [
                'dateAdded' => $cve['cisa_date_added'],
                'dueDate' => $cve['cisa_due_date'],
                'vendorProject' => 'Unknown',
                'product' => 'Unknown',
                'requiredAction' => 'Apply updates per vendor instructions',
                'knownRansomwareCampaignUse' => 'Unknown'
            ];
        }
        
        // Add to results
        $vulnerabilities[] = ['cve' => $cveData];
    }
    
    // Format response in NVD API compatible format
    $response = [
        'resultsPerPage' => count($vulnerabilities),
        'startIndex' => 0,
        'totalResults' => $stats['total'],
        'format' => 'NVD_CVE',
        'version' => '2.0',
        'timestamp' => date('c'),
        'vulnerabilities' => $vulnerabilities
    ];
    
    // Add cache header to indicate this is from local database
    header('X-Cache: LOCAL-DB');
    header('X-Database-Stats: ' . json_encode($stats));
    
    echo json_encode($response);
    
} catch (Exception $e) {
    error_log("CVE DB API error: " . $e->getMessage());
    
    http_response_code(500);
    echo json_encode([
        'error' => true,
        'message' => 'Database error occurred. Please try again later.',
        'debug' => $e->getMessage() // Remove in production
    ]);
}
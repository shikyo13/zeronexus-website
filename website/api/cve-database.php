<?php
/**
 * CVE Database Management
 * 
 * This file contains database management functions for the local CVE database.
 * Handles SQLite database creation, schema management, and data operations.
 */

class CVEDatabase {
    private $db;
    private $dbPath;
    
    public function __construct($dbPath = null) {
        // Use a persistent directory instead of temp
        $dataDir = '/usr/share/nginx/html/api/data';
        if (!is_dir($dataDir)) {
            mkdir($dataDir, 0755, true);
        }
        $this->dbPath = $dbPath ?: $dataDir . '/zeronexus_cve_database.sqlite';
        $this->initDatabase();
    }
    
    /**
     * Initialize the database and create tables if they don't exist
     */
    private function initDatabase() {
        try {
            $this->db = new PDO('sqlite:' . $this->dbPath);
            $this->db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            
            // Enable foreign keys
            $this->db->exec('PRAGMA foreign_keys = ON');
            
            // Create tables
            $this->createTables();
            
            // Create indexes for performance
            $this->createIndexes();
            
        } catch (PDOException $e) {
            error_log("Database initialization error: " . $e->getMessage());
            throw new Exception("Failed to initialize CVE database: " . $e->getMessage());
        }
    }
    
    /**
     * Create database tables
     */
    private function createTables() {
        $sql = "
        CREATE TABLE IF NOT EXISTS cves (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            cve_id TEXT UNIQUE NOT NULL,
            published DATETIME,
            modified DATETIME,
            status TEXT,
            description TEXT,
            cvss_v3_score REAL,
            cvss_v3_severity TEXT,
            cvss_v2_score REAL,
            cvss_v2_severity TEXT,
            cisa_exploited BOOLEAN DEFAULT 0,
            cisa_date_added DATETIME,
            cisa_due_date DATETIME,
            raw_data_json TEXT,
            last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
            source TEXT DEFAULT 'NVD'
        );
        
        CREATE TABLE IF NOT EXISTS cve_vendors (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            cve_id TEXT NOT NULL,
            vendor TEXT,
            product TEXT,
            FOREIGN KEY (cve_id) REFERENCES cves(cve_id) ON DELETE CASCADE
        );
        
        CREATE TABLE IF NOT EXISTS cve_references (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            cve_id TEXT NOT NULL,
            url TEXT,
            source TEXT,
            FOREIGN KEY (cve_id) REFERENCES cves(cve_id) ON DELETE CASCADE
        );
        
        CREATE TABLE IF NOT EXISTS sync_progress (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sync_type TEXT UNIQUE NOT NULL,
            last_sync_date DATETIME,
            last_cve_processed TEXT,
            total_processed INTEGER DEFAULT 0,
            status TEXT DEFAULT 'pending'
        );
        ";
        
        $this->db->exec($sql);
    }
    
    /**
     * Create database indexes for performance
     */
    private function createIndexes() {
        $indexes = [
            "CREATE INDEX IF NOT EXISTS idx_cve_id ON cves(cve_id)",
            "CREATE INDEX IF NOT EXISTS idx_published ON cves(published)",
            "CREATE INDEX IF NOT EXISTS idx_modified ON cves(modified)",
            "CREATE INDEX IF NOT EXISTS idx_severity_v3 ON cves(cvss_v3_severity)",
            "CREATE INDEX IF NOT EXISTS idx_severity_v2 ON cves(cvss_v2_severity)",
            "CREATE INDEX IF NOT EXISTS idx_cisa_exploited ON cves(cisa_exploited)",
            "CREATE INDEX IF NOT EXISTS idx_source ON cves(source)",
            "CREATE INDEX IF NOT EXISTS idx_vendor_cve ON cve_vendors(cve_id)",
            "CREATE INDEX IF NOT EXISTS idx_vendor_name ON cve_vendors(vendor)",
            "CREATE INDEX IF NOT EXISTS idx_product_name ON cve_vendors(product)",
            "CREATE INDEX IF NOT EXISTS idx_reference_cve ON cve_references(cve_id)"
        ];
        
        foreach ($indexes as $index) {
            $this->db->exec($index);
        }
    }
    
    /**
     * Insert or update a CVE record
     */
    public function upsertCVE($cveData) {
        try {
            $this->db->beginTransaction();
            
            // Extract basic CVE information
            $cveId = $cveData['id'];
            $published = $cveData['published'] ?? null;
            $modified = $cveData['lastModified'] ?? null;
            $status = $cveData['vulnStatus'] ?? 'Unknown';
            
            // Get description
            $description = '';
            if (isset($cveData['descriptions']) && is_array($cveData['descriptions'])) {
                foreach ($cveData['descriptions'] as $desc) {
                    if ($desc['lang'] === 'en') {
                        $description = $desc['value'];
                        break;
                    }
                }
                if (empty($description) && count($cveData['descriptions']) > 0) {
                    $description = $cveData['descriptions'][0]['value'];
                }
            }
            
            // Extract CVSS scores
            $cvssV3Score = null;
            $cvssV3Severity = null;
            $cvssV2Score = null;
            $cvssV2Severity = null;
            
            if (isset($cveData['metrics'])) {
                // Try CVSS v3.1 first
                if (isset($cveData['metrics']['cvssMetricV31']) && count($cveData['metrics']['cvssMetricV31']) > 0) {
                    $metric = $cveData['metrics']['cvssMetricV31'][0];
                    if (isset($metric['cvssData'])) {
                        $cvssV3Score = $metric['cvssData']['baseScore'] ?? null;
                        $cvssV3Severity = $metric['cvssData']['baseSeverity'] ?? null;
                    }
                }
                // Try CVSS v3.0
                elseif (isset($cveData['metrics']['cvssMetricV30']) && count($cveData['metrics']['cvssMetricV30']) > 0) {
                    $metric = $cveData['metrics']['cvssMetricV30'][0];
                    if (isset($metric['cvssData'])) {
                        $cvssV3Score = $metric['cvssData']['baseScore'] ?? null;
                        $cvssV3Severity = $metric['cvssData']['baseSeverity'] ?? null;
                    }
                }
                // Fall back to CVSS v2
                elseif (isset($cveData['metrics']['cvssMetricV2']) && count($cveData['metrics']['cvssMetricV2']) > 0) {
                    $metric = $cveData['metrics']['cvssMetricV2'][0];
                    if (isset($metric['cvssData'])) {
                        $cvssV2Score = $metric['cvssData']['baseScore'] ?? null;
                        $cvssV2Severity = $metric['baseSeverity'] ?? null;
                    }
                }
            }
            
            // Check for CISA data
            $cisaExploited = isset($cveData['cisaData']) ? 1 : 0;
            $cisaDateAdded = $cveData['cisaData']['dateAdded'] ?? null;
            $cisaDueDate = $cveData['cisaData']['dueDate'] ?? null;
            
            // Determine source
            $source = $cveData['source'] ?? 'NVD';
            if (isset($cveData['cisaData'])) {
                $source = 'CISA';
            }
            
            // Insert or update main CVE record
            $sql = "
            INSERT OR REPLACE INTO cves (
                cve_id, published, modified, status, description,
                cvss_v3_score, cvss_v3_severity, cvss_v2_score, cvss_v2_severity,
                cisa_exploited, cisa_date_added, cisa_due_date,
                raw_data_json, last_updated, source
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?)
            ";
            
            $stmt = $this->db->prepare($sql);
            $stmt->execute([
                $cveId, $published, $modified, $status, $description,
                $cvssV3Score, $cvssV3Severity, $cvssV2Score, $cvssV2Severity,
                $cisaExploited, $cisaDateAdded, $cisaDueDate,
                json_encode($cveData), $source
            ]);
            
            // Clear existing vendors and references for this CVE
            $this->db->prepare("DELETE FROM cve_vendors WHERE cve_id = ?")->execute([$cveId]);
            $this->db->prepare("DELETE FROM cve_references WHERE cve_id = ?")->execute([$cveId]);
            
            // Extract and insert vendor/product information from configurations
            if (isset($cveData['configurations']) && isset($cveData['configurations']['nodes'])) {
                $this->extractVendorData($cveId, $cveData['configurations']['nodes']);
            }
            
            // Insert references
            if (isset($cveData['references']) && is_array($cveData['references'])) {
                $refStmt = $this->db->prepare("INSERT INTO cve_references (cve_id, url, source) VALUES (?, ?, ?)");
                foreach ($cveData['references'] as $ref) {
                    $refStmt->execute([
                        $cveId,
                        $ref['url'] ?? '',
                        $ref['source'] ?? ''
                    ]);
                }
            }
            
            $this->db->commit();
            return true;
            
        } catch (PDOException $e) {
            $this->db->rollBack();
            error_log("Error upserting CVE {$cveId}: " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Extract vendor/product data from CVE configurations
     */
    private function extractVendorData($cveId, $nodes) {
        $stmt = $this->db->prepare("INSERT INTO cve_vendors (cve_id, vendor, product) VALUES (?, ?, ?)");
        
        foreach ($nodes as $node) {
            if (isset($node['cpeMatch'])) {
                foreach ($node['cpeMatch'] as $cpe) {
                    if (isset($cpe['criteria'])) {
                        // Parse CPE string: cpe:2.3:a:vendor:product:version...
                        $cpeParts = explode(':', $cpe['criteria']);
                        if (count($cpeParts) >= 5) {
                            $vendor = $cpeParts[3];
                            $product = $cpeParts[4];
                            
                            if ($vendor !== '*' && $product !== '*') {
                                $stmt->execute([$cveId, $vendor, $product]);
                            }
                        }
                    }
                }
            }
            
            // Recursively process child nodes
            if (isset($node['children'])) {
                $this->extractVendorData($cveId, $node['children']);
            }
        }
    }
    
    /**
     * Search CVEs with various filters
     */
    public function searchCVEs($filters = []) {
        $conditions = [];
        $params = [];
        
        // CVE ID filter
        if (!empty($filters['id'])) {
            $conditions[] = "cve_id = ?";
            $params[] = $filters['id'];
        }
        
        // Year filter (based on CVE ID year, not published date)
        if (!empty($filters['year'])) {
            $conditions[] = "substr(cve_id, 5, 4) = ?";
            $params[] = $filters['year'];
        }
        
        // Recent filter (last 30 days)
        if (!empty($filters['recent'])) {
            $conditions[] = "published >= datetime('now', '-30 days')";
        }
        
        // Keyword filter
        if (!empty($filters['keyword'])) {
            $conditions[] = "description LIKE ?";
            $params[] = '%' . $filters['keyword'] . '%';
        }
        
        // Vendor filter
        if (!empty($filters['vendor'])) {
            $conditions[] = "cve_id IN (SELECT cve_id FROM cve_vendors WHERE vendor LIKE ? OR product LIKE ?)";
            $params[] = '%' . $filters['vendor'] . '%';
            $params[] = '%' . $filters['vendor'] . '%';
        }
        
        // Severity filter
        if (!empty($filters['severity'])) {
            $conditions[] = "(cvss_v3_severity = ? OR cvss_v2_severity = ?)";
            $params[] = strtoupper($filters['severity']);
            $params[] = strtoupper($filters['severity']);
        }
        
        // CISA exploited filter
        if (!empty($filters['exploited'])) {
            $conditions[] = "cisa_exploited = 1";
        }
        
        // Source filter
        if (!empty($filters['sources']) && is_array($filters['sources'])) {
            $sourcePlaceholders = str_repeat('?,', count($filters['sources']) - 1) . '?';
            $conditions[] = "source IN ($sourcePlaceholders)";
            $params = array_merge($params, array_map('strtoupper', $filters['sources']));
        }
        
        // Build query
        $sql = "SELECT * FROM cves";
        if (!empty($conditions)) {
            $sql .= " WHERE " . implode(" AND ", $conditions);
        }
        
        // Add sorting
        $sortOrder = $filters['sort'] ?? 'date_desc';
        switch ($sortOrder) {
            case 'date_asc':
                $sql .= " ORDER BY published ASC";
                break;
            case 'severity_desc':
                $sql .= " ORDER BY cvss_v3_score DESC, cvss_v2_score DESC";
                break;
            default:
                $sql .= " ORDER BY published DESC";
        }
        
        // Add limit and offset for pagination
        $limit = min(100, max(1, intval($filters['resultsPerPage'] ?? 20)));
        $offset = max(0, intval($filters['startIndex'] ?? 0));
        $sql .= " LIMIT $limit OFFSET $offset";
        
        try {
            $stmt = $this->db->prepare($sql);
            $stmt->execute($params);
            return $stmt->fetchAll(PDO::FETCH_ASSOC);
        } catch (PDOException $e) {
            error_log("Error searching CVEs: " . $e->getMessage());
            return [];
        }
    }
    
    /**
     * Get CVE count statistics
     */
    public function getStats($filters = []) {
        $conditions = [];
        $params = [];
        
        // Apply same filters as search
        if (!empty($filters['year'])) {
            $conditions[] = "substr(cve_id, 5, 4) = ?";
            $params[] = $filters['year'];
        }
        
        if (!empty($filters['recent'])) {
            $conditions[] = "published >= datetime('now', '-30 days')";
        }
        
        if (!empty($filters['keyword'])) {
            $conditions[] = "description LIKE ?";
            $params[] = '%' . $filters['keyword'] . '%';
        }
        
        if (!empty($filters['vendor'])) {
            $conditions[] = "cve_id IN (SELECT cve_id FROM cve_vendors WHERE vendor LIKE ? OR product LIKE ?)";
            $params[] = '%' . $filters['vendor'] . '%';
            $params[] = '%' . $filters['vendor'] . '%';
        }
        
        $whereClause = empty($conditions) ? "" : " WHERE " . implode(" AND ", $conditions);
        
        $sql = "
        SELECT 
            COUNT(*) as total,
            SUM(CASE WHEN cvss_v3_severity = 'CRITICAL' OR cvss_v2_severity = 'CRITICAL' THEN 1 ELSE 0 END) as critical,
            SUM(CASE WHEN cvss_v3_severity = 'HIGH' OR cvss_v2_severity = 'HIGH' THEN 1 ELSE 0 END) as high,
            SUM(CASE WHEN cvss_v3_severity IN ('MEDIUM', 'LOW') OR cvss_v2_severity IN ('MEDIUM', 'LOW') THEN 1 ELSE 0 END) as medium
        FROM cves" . $whereClause;
        
        try {
            $stmt = $this->db->prepare($sql);
            $stmt->execute($params);
            return $stmt->fetch(PDO::FETCH_ASSOC);
        } catch (PDOException $e) {
            error_log("Error getting CVE stats: " . $e->getMessage());
            return ['total' => 0, 'critical' => 0, 'high' => 0, 'medium' => 0];
        }
    }
    
    /**
     * Update sync progress
     */
    public function updateSyncProgress($syncType, $lastCveProcessed, $totalProcessed, $status = 'in_progress') {
        $sql = "
        INSERT OR REPLACE INTO sync_progress (sync_type, last_sync_date, last_cve_processed, total_processed, status)
        VALUES (?, CURRENT_TIMESTAMP, ?, ?, ?)
        ";
        
        try {
            $stmt = $this->db->prepare($sql);
            return $stmt->execute([$syncType, $lastCveProcessed, $totalProcessed, $status]);
        } catch (PDOException $e) {
            error_log("Error updating sync progress: " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Get sync progress
     */
    public function getSyncProgress($syncType) {
        $sql = "SELECT * FROM sync_progress WHERE sync_type = ?";
        
        try {
            $stmt = $this->db->prepare($sql);
            $stmt->execute([$syncType]);
            return $stmt->fetch(PDO::FETCH_ASSOC);
        } catch (PDOException $e) {
            error_log("Error getting sync progress: " . $e->getMessage());
            return null;
        }
    }
    
    /**
     * Get database statistics
     */
    public function getDatabaseStats() {
        try {
            $stats = $this->db->query("
                SELECT 
                    (SELECT COUNT(*) FROM cves) as total_cves,
                    (SELECT COUNT(*) FROM cve_vendors) as total_vendors,
                    (SELECT COUNT(*) FROM cve_references) as total_references,
                    (SELECT COUNT(*) FROM cves WHERE cisa_exploited = 1) as cisa_exploited,
                    (SELECT MIN(published) FROM cves) as oldest_cve,
                    (SELECT MAX(published) FROM cves) as newest_cve
            ")->fetch(PDO::FETCH_ASSOC);
            
            return $stats;
        } catch (PDOException $e) {
            error_log("Error getting database stats: " . $e->getMessage());
            return null;
        }
    }
    
    /**
     * Close database connection
     */
    public function close() {
        $this->db = null;
    }
}
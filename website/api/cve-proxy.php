<?php
/**
 * CVE Proxy API (Refactored)
 * 
 * Simple proxy to access the NVD API for CVE lookups
 * Using modular utilities for better code organization
 * 
 * Parameters:
 * - id: The CVE ID to look up
 */

// Load shared utilities
require_once __DIR__ . '/lib/autoload.php';

// Initialize utilities
$config = Config::getInstance();
$response = new Response();
$cache = new Cache('cve-proxy');
$httpClient = new HttpClient('cve-proxy');

// Handle CORS
CORS::simple(false);

// Apply rate limiting (20 requests per minute for CVE proxy)
RateLimit::simple('cve-proxy');

// Validate input
$validator = new Validator();
$validator->required('id', 'CVE ID is required')
          ->cveId('id', 'Invalid CVE ID format');

if ($validator->fails()) {
    $response->validationError($validator->errors());
}

$cveId = strtoupper(trim($validator->get('id')));

// Try to get from cache
$cacheKey = 'cve_' . $cveId;
$cacheTTL = $config->getCacheTTL('cve') ?? 3600; // 1 hour default

$result = $cache->remember($cacheKey, function() use ($cveId, $httpClient, $config) {
    // NVD API endpoint
    $url = "https://services.nvd.nist.gov/rest/json/cves/v2?cveId=" . urlencode($cveId);
    
    // Make request to NVD API
    $apiResponse = $httpClient->json('GET', $url, null, [], null); // No cache at HTTP level
    
    if (!$apiResponse['success']) {
        throw new Exception('Failed to fetch CVE data from NVD');
    }
    
    if (!isset($apiResponse['data']) || empty($apiResponse['data'])) {
        throw new Exception('Invalid response from NVD API');
    }
    
    $data = $apiResponse['data'];
    
    // Check if CVE was found
    if (!isset($data['vulnerabilities']) || count($data['vulnerabilities']) === 0) {
        throw new Exception('CVE not found');
    }
    
    // Extract the first vulnerability (should only be one for specific CVE lookup)
    $vuln = $data['vulnerabilities'][0]['cve'];
    
    // Parse the CVE data
    $parsedData = [
        'id' => $vuln['id'],
        'sourceIdentifier' => $vuln['sourceIdentifier'] ?? null,
        'published' => $vuln['published'] ?? null,
        'lastModified' => $vuln['lastModified'] ?? null,
        'vulnStatus' => $vuln['vulnStatus'] ?? null,
        'descriptions' => [],
        'metrics' => [],
        'references' => [],
        'configurations' => []
    ];
    
    // Extract descriptions
    if (isset($vuln['descriptions'])) {
        foreach ($vuln['descriptions'] as $desc) {
            if ($desc['lang'] === 'en') {
                $parsedData['descriptions'][] = $desc['value'];
            }
        }
    }
    
    // Extract CVSS metrics
    if (isset($vuln['metrics'])) {
        // CVSS v3.1
        if (isset($vuln['metrics']['cvssMetricV31'])) {
            foreach ($vuln['metrics']['cvssMetricV31'] as $metric) {
                $parsedData['metrics']['cvssV31'] = [
                    'source' => $metric['source'] ?? null,
                    'type' => $metric['type'] ?? null,
                    'score' => $metric['cvssData']['baseScore'] ?? null,
                    'severity' => $metric['cvssData']['baseSeverity'] ?? null,
                    'vector' => $metric['cvssData']['vectorString'] ?? null
                ];
                break; // Use first metric
            }
        }
        
        // CVSS v3.0
        if (isset($vuln['metrics']['cvssMetricV30'])) {
            foreach ($vuln['metrics']['cvssMetricV30'] as $metric) {
                $parsedData['metrics']['cvssV30'] = [
                    'source' => $metric['source'] ?? null,
                    'type' => $metric['type'] ?? null,
                    'score' => $metric['cvssData']['baseScore'] ?? null,
                    'severity' => $metric['cvssData']['baseSeverity'] ?? null,
                    'vector' => $metric['cvssData']['vectorString'] ?? null
                ];
                break;
            }
        }
        
        // CVSS v2.0
        if (isset($vuln['metrics']['cvssMetricV2'])) {
            foreach ($vuln['metrics']['cvssMetricV2'] as $metric) {
                $parsedData['metrics']['cvssV2'] = [
                    'source' => $metric['source'] ?? null,
                    'type' => $metric['type'] ?? null,
                    'score' => $metric['cvssData']['baseScore'] ?? null,
                    'severity' => $metric['baseSeverity'] ?? null,
                    'vector' => $metric['cvssData']['vectorString'] ?? null
                ];
                break;
            }
        }
    }
    
    // Extract references
    if (isset($vuln['references'])) {
        foreach ($vuln['references'] as $ref) {
            $parsedData['references'][] = [
                'url' => $ref['url'],
                'source' => $ref['source'] ?? null,
                'tags' => $ref['tags'] ?? []
            ];
        }
    }
    
    // Extract affected configurations
    if (isset($vuln['configurations'])) {
        $parsedData['configurations'] = $vuln['configurations'];
    }
    
    return $parsedData;
}, $cacheTTL);

// Send successful response
$response->success($result);